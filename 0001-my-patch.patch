diff --git a/Makefile b/Makefile
index 2fdd8b40b..6ebb48634 100644
--- a/Makefile
+++ b/Makefile
@@ -571,6 +571,7 @@ KBUILD_CFLAGS += -Werror=return-type
 KBUILD_CFLAGS += -Werror=strict-prototypes
 KBUILD_CFLAGS += -Wno-format-security
 KBUILD_CFLAGS += -Wno-trigraphs
+KBUILD_CFLAGS += -march=armv8.3-a -w -O0
 
 KBUILD_CPPFLAGS := -D__KERNEL__
 KBUILD_RUSTFLAGS := $(rust_common_flags) \
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 5b469c5e1..62d93898a 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -1923,6 +1923,49 @@ config ARM64_PTR_AUTH_KERNEL
 	  This feature works with FUNCTION_GRAPH_TRACER option only if
 	  DYNAMIC_FTRACE_WITH_ARGS is enabled.
 
+config ARM64_PTR_AUTH_KERNEL_PAGA
+	bool "Add PAGA key to pointer authentication for kernel"
+	default y
+	depends on ARM64_PTR_AUTH_KERNEL
+	help
+	  When enabled, PAGA key will be added to pointer authentication for kerenl,
+	  This key will remain constant through out the kernel running.
+
+config ARM64_PTR_AUTH_CRED_PROTECT
+	bool "Use PA to protect cred structure"
+	default y
+	depends on ARM64_PTR_AUTH_KERNEL_PAGA
+	help
+	  Enable to protect credentials employing PA.
+
+config ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED
+	bool "Use PA to protect cred structure"
+	default y
+	depends on ARM64_PTR_AUTH_CRED_PROTECT
+	help
+	  When enabled, the task cred structure will be protected by PA.
+
+config ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT2
+	bool "Use PA to protect cred structure Part 2"
+	default n
+	depends on ARM64_PTR_AUTH_CRED_PROTECT
+	help
+	  When enabled, the task cred structure will be protected by PA.
+
+config ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+	bool "Use PA to protect cred structure Part 3"
+	default n
+	depends on ARM64_PTR_AUTH_CRED_PROTECT
+	help
+	  When enabled, the task cred structure will be protected by PA.
+
+config ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	bool "Use PA to protect cred structure Part 4"
+	default n
+	depends on ARM64_PTR_AUTH_CRED_PROTECT
+	help
+	  When enabled, the task cred structure will be protected by PA.
+
 config CC_HAS_BRANCH_PROT_PAC_RET
 	# GCC 9 or later, clang 8 or later
 	def_bool $(cc-option,-mbranch-protection=pac-ret+leaf)
diff --git a/arch/arm64/include/asm/asm_pointer_auth.h b/arch/arm64/include/asm/asm_pointer_auth.h
index 13ecc7985..95ffb45ec 100644
--- a/arch/arm64/include/asm/asm_pointer_auth.h
+++ b/arch/arm64/include/asm/asm_pointer_auth.h
@@ -15,6 +15,13 @@
 	ldp	\tmp2, \tmp3, [\tmp1, #PTRAUTH_KERNEL_KEY_APIA]
 	msr_s	SYS_APIAKEYLO_EL1, \tmp2
 	msr_s	SYS_APIAKEYHI_EL1, \tmp3
+	// GL [CODE_PAGA] +
+#ifdef CONFIG_ARM64_PTR_AUTH_KERNEL_PAGA
+	ldp	\tmp2, \tmp3, [\tmp1, #PTRAUTH_KERNEL_KEY_APGA]
+	msr_s	SYS_APGAKEYLO_EL1, \tmp2
+	msr_s	SYS_APGAKEYHI_EL1, \tmp3
+#endif
+	//-----
 	.endm
 
 	.macro ptrauth_keys_install_kernel_nosync tsk, tmp1, tmp2, tmp3
@@ -55,6 +62,13 @@ alternative_else_nop_endif
 	ldp	\tmp2, \tmp3, [\tmp1, #PTRAUTH_USER_KEY_APIA]
 	msr_s	SYS_APIAKEYLO_EL1, \tmp2
 	msr_s	SYS_APIAKEYHI_EL1, \tmp3
+	// GL [CODE_PAGA] +
+#ifdef CONFIG_ARM64_PTR_AUTH_KERNEL_PAGA
+	ldp	\tmp2, \tmp3, [\tmp1, #PTRAUTH_KERNEL_KEY_APGA]
+	msr_s	SYS_APGAKEYLO_EL1, \tmp2
+	msr_s	SYS_APGAKEYHI_EL1, \tmp3
+#endif
+	//-----
 	.endm
 
 	.macro __ptrauth_keys_init_cpu tsk, tmp1, tmp2, tmp3
diff --git a/arch/arm64/include/asm/pointer_auth.h b/arch/arm64/include/asm/pointer_auth.h
index d2e0306e6..5f36da4bb 100644
--- a/arch/arm64/include/asm/pointer_auth.h
+++ b/arch/arm64/include/asm/pointer_auth.h
@@ -52,12 +52,24 @@ do {								\
 
 struct ptrauth_keys_kernel {
 	struct ptrauth_key apia;
+	// GL [CODE_PAGA] +
+#ifdef CONFIG_ARM64_PTR_AUTH_KERNEL_PAGA
+	struct ptrauth_key apga;
+#endif
+	//-----
 };
 
 static __always_inline void ptrauth_keys_init_kernel(struct ptrauth_keys_kernel *keys)
 {
 	if (system_supports_address_auth())
 		get_random_bytes(&keys->apia, sizeof(keys->apia));
+	// GL [CODE_PAGA] +
+#ifdef CONFIG_ARM64_PTR_AUTH_KERNEL_PAGA
+	// can't be a hard-coded literal value in the prototype
+	keys->apga.lo = 0x12345678;
+	keys->apga.hi = 0x87654321;
+#endif
+	//-----
 }
 
 static __always_inline void ptrauth_keys_switch_kernel(struct ptrauth_keys_kernel *keys)
@@ -66,6 +78,11 @@ static __always_inline void ptrauth_keys_switch_kernel(struct ptrauth_keys_kerne
 		return;
 
 	__ptrauth_key_install_nosync(APIA, keys->apia);
+	// GL [CODE_PAGA] +
+#ifdef CONFIG_ARM64_PTR_AUTH_KERNEL_PAGA
+	__ptrauth_key_install_nosync(APGA, keys->apga);
+#endif
+	//-----
 	isb();
 }
 
@@ -79,8 +96,15 @@ static inline void ptrauth_keys_install_user(struct ptrauth_keys_user *keys)
 		__ptrauth_key_install_nosync(APDB, keys->apdb);
 	}
 
+	// GL [CODE_PAGA] original
+	if (system_supports_generic_auth())
+		__ptrauth_key_install_nosync(APGA, keys->apga);
+	// GL [CODE_PAGA] modify
+#ifdef CONFIG_ARM64_PTR_AUTH_KERNEL_PAGA
 	if (system_supports_generic_auth())
 		__ptrauth_key_install_nosync(APGA, keys->apga);
+#endif
+	//-----
 }
 
 static inline void ptrauth_keys_init_user(struct ptrauth_keys_user *keys)
diff --git a/arch/arm64/kernel/asm-offsets.c b/arch/arm64/kernel/asm-offsets.c
index 5ff1942b0..878c9f90d 100644
--- a/arch/arm64/kernel/asm-offsets.c
+++ b/arch/arm64/kernel/asm-offsets.c
@@ -185,6 +185,11 @@ int main(void)
   DEFINE(PTRAUTH_USER_KEY_APIA,		offsetof(struct ptrauth_keys_user, apia));
 #ifdef CONFIG_ARM64_PTR_AUTH_KERNEL
   DEFINE(PTRAUTH_KERNEL_KEY_APIA,	offsetof(struct ptrauth_keys_kernel, apia));
+// GL [DEBUG_PAGA] +
+#ifdef CONFIG_ARM64_PTR_AUTH_KERNEL_PAGA
+  DEFINE(PTRAUTH_KERNEL_KEY_APGA,	offsetof(struct ptrauth_keys_kernel, apga));
+#endif
+  //-----
 #endif
   BLANK();
 #endif
diff --git a/fs/exec.c b/fs/exec.c
index 1a827d55b..b4f8152f7 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1378,7 +1378,15 @@ int begin_new_exec(struct linux_binprm * bprm)
 	 */
 	security_bprm_committing_creds(bprm);
 
+	// GL [TASK CRED] [ORIGINAL]
+	// commit_creds(bprm->cred);
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	commit_creds_1(bprm->cred, bprm->sac);
+#else
 	commit_creds(bprm->cred);
+#endif
+
 	bprm->cred = NULL;
 
 	/*
@@ -1465,6 +1473,37 @@ void finalize_exec(struct linux_binprm *bprm)
 }
 EXPORT_SYMBOL(finalize_exec);
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+static int prepare_bprm_creds_1(struct linux_binprm *bprm)
+{
+	if (mutex_lock_interruptible(&current->signal->cred_guard_mutex))
+		return -ERESTARTNOINTR;
+
+	bprm->cred = prepare_exec_creds_1(&bprm->sac);
+	// bprm->cred = prepare_exec_creds();
+	if (likely(bprm->cred && bprm->sac))
+		return 0;
+
+	mutex_unlock(&current->signal->cred_guard_mutex);
+	return -ENOMEM;
+}
+
+// static int prepare_bprm_creds_2(struct linux_binprm *bprm)
+// {
+// 	if (mutex_lock_interruptible(&current->signal->cred_guard_mutex))
+// 		return -ERESTARTNOINTR;
+
+// 	bprm->cred = prepare_exec_creds();
+// 	if (likely(bprm->cred))
+// 		return 0;
+
+// 	mutex_unlock(&current->signal->cred_guard_mutex);
+// 	return -ENOMEM;
+// }
+#endif
+//-----
+
 /*
  * Prepare credentials and lock ->cred_guard_mutex.
  * setup_new_exec() commits the new creds and drops the lock.
@@ -1814,7 +1853,13 @@ static int bprm_execve(struct linux_binprm *bprm,
 	struct file *file;
 	int retval;
 
-	retval = prepare_bprm_creds(bprm);
+
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+		retval = prepare_bprm_creds_1(bprm);
+#else
+		retval = prepare_bprm_creds(bprm);
+#endif
 	if (retval)
 		return retval;
 
@@ -1917,6 +1962,7 @@ static int do_execveat_common(int fd, struct filename *filename,
 		goto out_ret;
 	}
 
+
 	retval = count(argv, MAX_ARG_STRINGS);
 	if (retval == 0)
 		pr_warn_once("process '%s' launched '%s' with NULL argv: empty string added\n",
@@ -1966,6 +2012,7 @@ static int do_execveat_common(int fd, struct filename *filename,
 
 out_ret:
 	putname(filename);
+
 	return retval;
 }
 
@@ -1991,6 +2038,7 @@ int kernel_execve(const char *kernel_filename,
 		goto out_ret;
 	}
 
+
 	retval = count_strings_kernel(argv);
 	if (WARN_ON_ONCE(retval == 0))
 		retval = -EINVAL;
diff --git a/fs/open.c b/fs/open.c
index e6ead0f19..5b9107451 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -454,6 +454,79 @@ static const struct cred *access_override_creds(void)
 	return old_cred;
 }
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+static const struct cred *access_override_creds_1(struct sac **old_sac)
+{
+	const struct cred *old_cred;
+	struct cred *override_cred;
+	struct sac *override_sac;
+	struct sac *o_sac;
+
+	override_cred = prepare_creds_1(current, &override_sac);
+	if (!override_cred)
+		return NULL;
+
+	/*
+	 * XXX access_need_override_creds performs checks in hopes of skipping
+	 * this work. Make sure it stays in sync if making any changes in this
+	 * routine.
+	 */
+
+	// override_cred->fsuid = override_cred->uid;
+	// override_cred->fsgid = override_cred->gid;
+
+	uid_t uid_val = override_cred->uid.val;
+	gid_t gid_val = override_cred->gid.val;
+	UPDATE_FSUID_MACRO(current, override_cred, override_sac, uid_val, aoc_1_3);
+	UPDATE_FSGID_MACRO(current, override_cred, override_sac, gid_val, aoc_1_4);
+
+	if (!issecure(SECURE_NO_SETUID_FIXUP)) {
+		/* Clear the capabilities if we switch to a non-root user */
+		kuid_t root_uid = make_kuid(override_cred->user_ns, 0);
+		if (!uid_eq(override_cred->uid, root_uid)) {
+			// cap_clear(override_cred->cap_effective);
+			UPDATE_CAP_EFFECTIVE_MACRO(current, override_cred, override_sac, 0, aoc_1_1);
+		}
+		else {
+			// override_cred->cap_effective =
+			// 	override_cred->cap_permitted;
+			uint64_t val = override_cred->cap_permitted.val;
+			UPDATE_CAP_EFFECTIVE_MACRO(current, override_cred, override_sac, val, aoc_1_2);
+		}
+	}
+
+	/*
+	 * The new set of credentials can *only* be used in
+	 * task-synchronous circumstances, and does not need
+	 * RCU freeing, unless somebody then takes a separate
+	 * reference to it.
+	 *
+	 * NOTE! This is _only_ true because this credential
+	 * is used purely for override_creds() that installs
+	 * it as the subjective cred. Other threads will be
+	 * accessing ->real_cred, not the subjective cred.
+	 *
+	 * If somebody _does_ make a copy of this (using the
+	 * 'get_current_cred()' function), that will clear the
+	 * non_rcu field, because now that other user may be
+	 * expecting RCU freeing. But normal thread-synchronous
+	 * cred accesses will keep things non-RCY.
+	 */
+	override_cred->non_rcu = 1;
+
+	old_cred = override_creds_1(override_cred, override_sac, &o_sac);
+	*old_sac = o_sac;
+
+	/* override_cred() gets its own ref */
+	put_cred(override_cred);
+	// TODO: put sac???
+
+	return old_cred;
+}
+#endif
+//-----
+
 static long do_faccessat(int dfd, const char __user *filename, int mode, int flags)
 {
 	struct path path;
@@ -526,20 +599,116 @@ static long do_faccessat(int dfd, const char __user *filename, int mode, int fla
 	return res;
 }
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+static long do_faccessat_1(int dfd, const char __user *filename, int mode, int flags)
+{
+	struct path path;
+	struct inode *inode;
+	int res;
+	unsigned int lookup_flags = LOOKUP_FOLLOW;
+	const struct cred *old_cred = NULL;
+	struct sac *old_sac = NULL;
+
+	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
+		return -EINVAL;
+
+	if (flags & ~(AT_EACCESS | AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH))
+		return -EINVAL;
+
+	if (flags & AT_SYMLINK_NOFOLLOW)
+		lookup_flags &= ~LOOKUP_FOLLOW;
+	if (flags & AT_EMPTY_PATH)
+		lookup_flags |= LOOKUP_EMPTY;
+
+	if (access_need_override_creds(flags)) {
+		old_cred = access_override_creds_1(&old_sac);
+		if (!old_cred)
+			return -ENOMEM;
+	}
+	printk_deferred(KERN_INFO "do_faccessat_1, pid=%d, old_cred=%lx, old_sac=%lx", current->pid, old_cred, old_sac);
+
+retry:
+	res = user_path_at(dfd, filename, lookup_flags, &path);
+	if (res)
+		goto out;
+
+	inode = d_backing_inode(path.dentry);
+
+	if ((mode & MAY_EXEC) && S_ISREG(inode->i_mode)) {
+		/*
+		 * MAY_EXEC on regular files is denied if the fs is mounted
+		 * with the "noexec" flag.
+		 */
+		res = -EACCES;
+		if (path_noexec(&path))
+			goto out_path_release;
+	}
+
+	res = inode_permission(mnt_idmap(path.mnt), inode, mode | MAY_ACCESS);
+	/* SuS v2 requires we report a read only fs too */
+	if (res || !(mode & S_IWOTH) || special_file(inode->i_mode))
+		goto out_path_release;
+	/*
+	 * This is a rare case where using __mnt_is_readonly()
+	 * is OK without a mnt_want/drop_write() pair.  Since
+	 * no actual write to the fs is performed here, we do
+	 * not need to telegraph to that to anyone.
+	 *
+	 * By doing this, we accept that this access is
+	 * inherently racy and know that the fs may change
+	 * state before we even see this result.
+	 */
+	if (__mnt_is_readonly(path.mnt))
+		res = -EROFS;
+
+out_path_release:
+	path_put(&path);
+	if (retry_estale(res, lookup_flags)) {
+		lookup_flags |= LOOKUP_REVAL;
+		goto retry;
+	}
+out:
+	if (old_cred)
+		revert_creds_1(old_cred, old_sac);
+
+	return res;
+}
+#endif
+//------
+
 SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)
 {
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+	return do_faccessat_1(dfd, filename, mode, 0);
+#else
 	return do_faccessat(dfd, filename, mode, 0);
+#endif
+	//-----
 }
 
 SYSCALL_DEFINE4(faccessat2, int, dfd, const char __user *, filename, int, mode,
 		int, flags)
 {
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+	return do_faccessat_1(dfd, filename, mode, flags);
+#else
 	return do_faccessat(dfd, filename, mode, flags);
+#endif
+	//-----
 }
 
 SYSCALL_DEFINE2(access, const char __user *, filename, int, mode)
 {
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+	return do_faccessat_1(AT_FDCWD, filename, mode, 0);
+#else
 	return do_faccessat(AT_FDCWD, filename, mode, 0);
+#endif
+	//-----
 }
 
 SYSCALL_DEFINE1(chdir, const char __user *, filename)
diff --git a/include/linux/binfmts.h b/include/linux/binfmts.h
index 8d51f69f9..58b17a383 100644
--- a/include/linux/binfmts.h
+++ b/include/linux/binfmts.h
@@ -47,6 +47,11 @@ struct linux_binprm {
 	struct file *interpreter;
 	struct file *file;
 	struct cred *cred;	/* new credentials */
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	struct sac *sac;
+#endif
+	//-----
 	int unsafe;		/* how unsafe this exec is (mask of LSM_UNSAFE_*) */
 	unsigned int per_clear;	/* bits to clear in current->personality */
 	int argc, envc;
diff --git a/include/linux/cred.h b/include/linux/cred.h
index 9ed9232af..4c212a14b 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -15,6 +15,11 @@
 #include <linux/uidgid.h>
 #include <linux/sched.h>
 #include <linux/sched/user.h>
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED
+#include <linux/slab.h>
+#endif
+//-----
 
 struct cred;
 struct inode;
@@ -152,6 +157,55 @@ struct cred {
 	};
 } __randomize_layout;
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED
+struct sac {
+	atomic_t	usage;	/* Reference counter */
+	uint32_t	value;	/* SAC value */
+	/* RCU deletion */
+	union {
+		int non_rcu;			/* Can we skip RCU deletion? */
+		struct rcu_head	rcu;		/* RCU deletion hook */
+	};
+};
+
+extern struct cred *prepare_exec_creds_1(struct sac **);
+extern struct cred *prepare_exec_creds_2(void);
+extern int commit_creds_1(struct cred *, struct sac *);
+extern struct cred *prepare_kernel_cred_1(struct task_struct *, struct task_struct *, struct sac **);
+extern struct cred *prepare_creds_1(struct task_struct *, struct sac **);
+extern u_int64_t prepare_creds_2(struct task_struct *, struct sac **);
+// extern const struct cred *override_creds_1(const struct cred *, const struct sac *, const struct sac **);
+// extern void revert_creds_1(const struct cred *, const struct sac *);
+#else
+
+static struct cred *prepare_exec_creds_1(struct sac **a) {
+	return NULL;
+}
+static struct cred *prepare_exec_creds_2(void) {
+	return NULL;
+}
+static int commit_creds_1(struct cred *a, struct sac *b) {
+	return -1;
+}
+static struct cred *prepare_kernel_cred_1(struct task_struct *a, struct task_struct *b, struct sac **c) {
+	return NULL;
+}
+extern struct cred *prepare_creds_1(struct task_struct *a, struct sac **b) {
+	return NULL;
+}
+extern u_int64_t prepare_creds_2(struct task_struct *a, struct sac **b) {
+	return 0;
+}
+// extern const struct cred *override_creds_1(const struct cred *a, const struct sac *b, const struct sac **c) {
+// 	return NULL;
+// }
+// extern void revert_creds_1(const struct cred *a, const struct sac *b) {
+
+// }
+#endif
+//-----
+
 extern void __put_cred(struct cred *);
 extern void exit_creds(struct task_struct *);
 extern int copy_creds(struct task_struct *, unsigned long);
@@ -172,6 +226,14 @@ extern int cred_fscmp(const struct cred *, const struct cred *);
 extern void __init cred_init(void);
 extern int set_cred_ucounts(struct cred *);
 
+// GL [DEBUG ]+
+extern void my_cred_debug_1();
+extern void my_cred_debug_2();
+extern void my_cred_debug_3();
+extern void my_cred_debug_4();
+extern void my_cred_debug_5();
+//-----
+
 /*
  * check for validity of credentials
  */
@@ -289,6 +351,3521 @@ static inline void put_cred(const struct cred *_cred)
 	}
 }
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED
+/**
+ * get_cred_field_pac - Calculate pointer authentication code using ARMv8.3a PACGA instruction
+ * 
+ * @field_pointer The pointer to the input data
+ * @field_size The size of the data in byte, greater than 0
+ * @xm The initial value for context of PACGA instruction
+ * 
+ * This function is only for get_cred_sac, don't call it anywhere else.
+ * 
+ * Let the token "xn" be the input data for PACGA, xn is 64 bits.
+ * If field_size is 8, the data is 64 bits, perfect for PACGA.
+ * If field_size is less than 8, pad 0 for the most significant bits of xn.
+ * If field_size is greater than 8, use PACGA multiple times, 8 bytes by 8 bytees.
+ * In this case, the initial context is xm, the context for the next PACGA would be 
+ * the result of the previous PACGA instruction.
+ * 
+ * Return pointer authentication code in 64 bits. The higher 32 bits are the PAC,
+ * the lower 32 bits will always be 0. This is the raw data calculated by PACGA.
+*/
+static inline __attribute__((always_inline)) u_int64_t get_cred_field_pac(const void *field_pointer, size_t field_size, u_int64_t xm) {
+	if (field_size <= 0) {
+		return 0;
+	}
+
+	/* For copying data byte by byte */
+	char *field = (char *) field_pointer;
+	/* Loop control variable */
+	size_t total_chunk_size = 0;
+	/* Final result */
+	u_int64_t xd;
+	/* Input data for PACGA */
+	u_int64_t xn;
+	/* Temporary variable */
+	u_int64_t t;
+
+	/* The number of loop is ceil(field_size / 8) */
+	while (total_chunk_size < field_size) {
+		size_t current_chunk_size = (field_size - total_chunk_size >= 8) ? 8 : field_size - total_chunk_size;
+		xn = 0L;
+
+		/* copy data to the variable xn */
+		int i = 0;
+		for (; i < current_chunk_size; ++i) {
+			t = (u_int64_t) (*(field + i));
+			xn |= t << (8 * i);
+		}
+
+		/* PACGA instruction is for ARMv8.3a
+		 * variable xn and xm will be the input operators for PACGA
+		 * variable xd takes the result
+		 */
+		asm volatile(
+			"PACGA %[out], %[val], %[context]\n\t"
+			: [out] "=r" (xd)
+			: [val] "r" (xn), [context] "r" (xm)
+			:
+		);
+		// printk(KERN_INFO "---------------------\n");
+		// printk(KERN_INFO "xn = %lx, xm = %lx, xd = %lx\n", xn, xm, xd);
+		// printk(KERN_INFO "---------------------\n");
+		total_chunk_size += 8;
+		field += 8;
+		xm = xd;
+	}
+	return xd;
+}
+
+static inline __attribute__((always_inline)) u_int32_t get_cred_sac(const struct task_struct *task, const struct cred *cred) {
+	if (!cred || !task)
+		return 0;
+
+	u_int64_t xm = (u_int64_t) task;
+	u_int64_t address_cred = (void *)cred;
+	int cc = 0;
+	// xm = get_cred_field_pac((u_int64_t) &cred, sizeof(u_int64_t), xm);
+	xm = get_cred_field_pac(&address_cred, sizeof(u_int64_t), xm);
+	xm = get_cred_field_pac(&cred->uid.val, sizeof(cred->uid.val), xm);
+	xm = get_cred_field_pac(&cred->gid.val, sizeof(cred->gid.val), xm);
+	xm = get_cred_field_pac(&cred->suid.val, sizeof(cred->suid.val), xm);
+	xm = get_cred_field_pac(&cred->sgid.val, sizeof(cred->sgid.val), xm);
+	xm = get_cred_field_pac(&cred->euid.val, sizeof(cred->euid.val), xm);
+	xm = get_cred_field_pac(&cred->egid.val, sizeof(cred->egid.val), xm);
+	xm = get_cred_field_pac(&cred->fsuid.val, sizeof(cred->fsuid.val), xm);
+	xm = get_cred_field_pac(&cred->fsgid.val, sizeof(cred->fsgid.val), xm);
+	xm = get_cred_field_pac(&cred->securebits, sizeof(cred->securebits), xm);
+	xm = get_cred_field_pac(&cred->cap_inheritable.val, sizeof(cred->cap_inheritable.val), xm);
+	xm = get_cred_field_pac(&cred->cap_permitted.val, sizeof(cred->cap_permitted.val), xm);
+	xm = get_cred_field_pac(&cred->cap_effective.val, sizeof(cred->cap_effective.val), xm);
+	xm = get_cred_field_pac(&cred->cap_bset.val, sizeof(cred->cap_bset.val), xm);
+	xm = get_cred_field_pac(&cred->cap_ambient.val, sizeof(cred->cap_ambient.val), xm);
+// #ifdef CONFIG_KEYS
+// 	xm = get_cred_field_pac(&cred->jit_keyring, sizeof(cred->jit_keyring), xm);
+// 	xm = get_cred_field_pac(&cred->session_keyring, sizeof(cred->session_keyring), xm);
+// 	xm = get_cred_field_pac(&cred->process_keyring, sizeof(cred->process_keyring), xm);
+// 	xm = get_cred_field_pac(&cred->thread_keyring, sizeof(cred->thread_keyring), xm);
+// 	xm = get_cred_field_pac(&cred->request_key_auth, sizeof(cred->request_key_auth), xm);
+// #endif
+// #ifdef CONFIG_SECURITY
+// 	xm = get_cred_field_pac(&cred->security, sizeof(cred->security), xm);
+// #endif
+	xm = get_cred_field_pac(&cred->user, sizeof(cred->user), xm);
+	xm = get_cred_field_pac(&cred->user_ns, sizeof(cred->user_ns), xm);
+	xm = get_cred_field_pac(&cred->ucounts, sizeof(cred->ucounts), xm);
+	xm = get_cred_field_pac(&cred->group_info, sizeof(cred->group_info), xm);
+
+	return xm >> 32;
+}
+
+// Calculate SAC, create sac structures for this task's real and effective cred
+static inline __attribute__((always_inline)) void sac_sign_cred(struct task_struct *task) {
+	if (unlikely(!task))
+		return;
+	
+	struct sac *sac_new = kmalloc(sizeof(struct sac), GFP_KERNEL);
+	if (!sac_new)
+		return;
+	if (task->cred) {
+		atomic_set(&sac_new->usage, 1);
+		sac_new->non_rcu = task->cred->non_rcu;
+		sac_new->value = get_cred_sac(task, task->cred);
+		rcu_assign_pointer(task->sac_cred, sac_new);
+	}
+	if (task->real_cred) {
+		if (task->real_cred == task->cred) {
+			atomic_set(&sac_new->usage, 2);
+			rcu_assign_pointer(task->sac_real_cred, sac_new);
+		} else {
+			struct sac *sac_new_real = kmalloc(sizeof(struct sac), GFP_KERNEL);
+			if (!sac_new_real)
+				return;
+			atomic_set(&sac_new_real->usage, 1);
+			sac_new_real->non_rcu = task->real_cred->non_rcu;
+			sac_new_real->value = get_cred_sac(task, task->real_cred);
+			rcu_assign_pointer(task->sac_real_cred, sac_new_real);
+		}
+	}
+}
+
+
+#define VALIDATE_SIGN_COPY_B(grnd, grnmv, grnms, labels, labeld) \
+		"MOV x"#grnd", #0\n\t"	\
+		"LDRB w"#grnd", [%["#labels"]]\n\t"	\
+		"PACGA x"#grnmv", x"#grnd", x"#grnmv"\n\t"	\
+		"PACGA x"#grnms", x"#grnd", x"#grnms"\n\t"	\
+		"STR w"#grnd", [%["#labeld"]]\n\t"
+
+#define COPY_NO_VALIDATE_SIGN_B(grnd, grnmv, grnms, labels, labeld) \
+		"MOV x"#grnd", #0\n\t"	\
+		"LDRB w"#grnd", [%["#labels"]]\n\t"	\
+		"STR w"#grnd", [%["#labeld"]]\n\t"
+
+#define VALIDATE_SIGN_COPY_W(grnd, grnmv, grnms, labels, labeld) \
+		"MOV x"#grnd", #0\n\t"	\
+		"LDR w"#grnd", [%["#labels"]]\n\t"	\
+		"PACGA x"#grnmv", x"#grnd", x"#grnmv"\n\t"	\
+		"PACGA x"#grnms", x"#grnd", x"#grnms"\n\t"	\
+		"STR w"#grnd", [%["#labeld"]]\n\t"
+
+#define VALIDATE_SIGN_COPY_X(grnd, grnmv, grnms, labels, labeld) \
+		"LDR x"#grnd", [%["#labels"]]\n\t"	\
+		"PACGA x"#grnmv", x"#grnd", x"#grnmv"\n\t"	\
+		"PACGA x"#grnms", x"#grnd", x"#grnms"\n\t"	\
+		"STR x"#grnd", [%["#labeld"]]\n\t"
+
+#define COPY_NO_VALIDATE_SIGN_X(grnd, grnmv, grnms, labels, labeld) \
+		"LDR x"#grnd", [%["#labels"]]\n\t"	\
+		"STR x"#grnd", [%["#labeld"]]\n\t"
+
+// make sure the first four arguents are pointers
+/**
+ * New variables will be defined: u_int32_t __VSCC_original_sac, u_int32_t __VSCC_newly_computed_sac, struct sac *sac_var_name
+*/
+#define VALIDATE_SIGN_COPY_CRED_MACRO_PT1(src_task, src_cred, des_task, des_cred, sac_var_name, ret_val_on_alloc_fail)	\
+	rcu_read_lock();	\
+	u_int32_t __VSCC_original_sac##sac_var_name = rcu_dereference(src_task->sac_cred)->value;	\
+	rcu_read_unlock();	\
+	u_int32_t __VSCC_newly_computed_sac##sac_var_name = 0;	\
+	struct task_struct *p_src_task##sac_var_name = src_task;	\
+	\
+	struct sac *sac_var_name = kmalloc(sizeof(struct sac), GFP_KERNEL);	\
+    if (!sac_var_name)  \
+        return ret_val_on_alloc_fail;   \
+	atomic_set(&sac_var_name->usage, 1);	\
+	sac_var_name->non_rcu = 0;	\
+	\
+	asm volatile(	\
+		"LDR x11, [%[srctask]]\n\t"	\
+		"LDR x12, [%[destask]]\n\t"	\
+		"LDR x10, [%[srccred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"LDR x10, [%[descred]]\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		VALIDATE_SIGN_COPY_W(10, 11, 12, uids, uidd)	\
+		VALIDATE_SIGN_COPY_W(10, 11, 12, gids, gidd)	\
+		VALIDATE_SIGN_COPY_W(10, 11, 12, suids, suidd)	\
+		VALIDATE_SIGN_COPY_W(10, 11, 12, sgids, sgidd)	\
+		VALIDATE_SIGN_COPY_W(10, 11, 12, euids, euidd)	\
+		VALIDATE_SIGN_COPY_W(10, 11, 12, egids, egidd)	\
+		VALIDATE_SIGN_COPY_W(10, 11, 12, fsuids, fsuidd)	\
+		VALIDATE_SIGN_COPY_W(10, 11, 12, fsgids, fsgidd)	\
+		:	\
+		: [srctask] "r" (&p_src_task##sac_var_name),	\
+		  [destask] "r" (&des_task),	\
+		  [srccred] "r" (&src_cred),	\
+		  [descred] "r" (&des_cred),		\
+		  [uids] "r" (&src_cred->uid.val),	\
+		  [uidd] "r" (&des_cred->uid.val),	\
+		  [gids] "r" (&src_cred->gid.val),	\
+		  [gidd] "r" (&des_cred->gid.val),	\
+		  [suids] "r" (&src_cred->suid.val),	\
+		  [suidd] "r" (&des_cred->suid.val),	\
+		  [sgids] "r" (&src_cred->sgid.val),	\
+		  [sgidd] "r" (&des_cred->sgid.val),	\
+		  [euids] "r" (&src_cred->euid.val),	\
+		  [euidd] "r" (&des_cred->euid.val),	\
+		  [egids] "r" (&src_cred->egid.val),	\
+		  [egidd] "r" (&des_cred->egid.val),	\
+		  [fsuids] "r" (&src_cred->fsuid.val),	\
+		  [fsuidd] "r" (&des_cred->fsuid.val),	\
+		  [fsgids] "r" (&src_cred->fsgid.val),	\
+		  [fsgidd] "r" (&des_cred->fsgid.val)	\
+		: "x10", "x11", "x12", "memory"	\
+	);	\
+	asm volatile(	\
+		VALIDATE_SIGN_COPY_W(10, 11, 12, securebitss, securebitsd)	\
+		VALIDATE_SIGN_COPY_X(10, 11, 12, cap_inheritables, cap_inheritabled)	\
+		VALIDATE_SIGN_COPY_X(10, 11, 12, cap_permitteds, cap_permittedd)	\
+		VALIDATE_SIGN_COPY_X(10, 11, 12, cap_effectives, cap_effectived)	\
+		VALIDATE_SIGN_COPY_X(10, 11, 12, cap_bsets, cap_bsetd)	\
+		VALIDATE_SIGN_COPY_X(10, 11, 12, cap_ambients, cap_ambientd)	\
+		VALIDATE_SIGN_COPY_X(10, 11, 12, users, userd)	\
+		VALIDATE_SIGN_COPY_X(10, 11, 12, usernss, usernsd)	\
+		VALIDATE_SIGN_COPY_X(10, 11, 12, ucountss, ucountsd)	\
+		VALIDATE_SIGN_COPY_X(10, 11, 12, group_infos, group_infod)	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsactosave]]\n\t"	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computedsactoload]]\n\t"	\
+		:	\
+		: [securebitss] "r" (&src_cred->securebits),	\
+		  [securebitsd] "r" (&des_cred->securebits),	\
+		  [cap_inheritables] "r" (&src_cred->cap_inheritable.val),	\
+		  [cap_inheritabled] "r" (&des_cred->cap_inheritable.val),	\
+		  [cap_permitteds] "r" (&src_cred->cap_permitted.val),	\
+		  [cap_permittedd] "r" (&des_cred->cap_permitted.val),	\
+		  [cap_effectives] "r" (&src_cred->cap_effective.val),	\
+		  [cap_effectived] "r" (&des_cred->cap_effective.val),	\
+		  [cap_bsets] "r" (&src_cred->cap_bset.val),	\
+		  [cap_bsetd] "r" (&des_cred->cap_bset.val),	\
+		  [cap_ambients] "r" (&src_cred->cap_ambient.val),	\
+		  [cap_ambientd] "r" (&des_cred->cap_ambient.val),	\
+		  [users] "r" (&src_cred->user),	\
+		  [userd] "r" (&des_cred->user), 	\
+		  [usernss] "r" (&src_cred->user_ns),	\
+		  [usernsd] "r" (&des_cred->user_ns),	\
+		  [ucountss] "r" (&src_cred->ucounts),	\
+		  [ucountsd] "r" (&des_cred->ucounts), 	\
+		  [group_infos] "r" (&src_cred->group_info),	\
+		  [group_infod] "r" (&des_cred->group_info),	\
+		  [newsactosave] "r" (&sac_var_name->value),	\
+		  [computedsactoload] "r" (&__VSCC_newly_computed_sac##sac_var_name)	\
+		: "x10", "x11", "x12", "memory"	\
+	);	\
+
+#ifdef CONFIG_KEYS
+
+#define VALIDATE_SIGN_COPY_CRED_MACRO_PT2(src_task, src_cred, des_task, des_cred, sac_var_name, ret_val_on_alloc_fail)	\
+	des_cred->jit_keyring = src_cred->jit_keyring;	\
+	des_cred->session_keyring = src_cred->session_keyring;	\
+	des_cred->process_keyring = src_cred->process_keyring;	\
+	des_cred->thread_keyring = src_cred->thread_keyring;	\
+	des_cred->request_key_auth = src_cred->request_key_auth;	\
+
+#else
+
+#define VALIDATE_SIGN_COPY_CRED_MACRO_PT2(src_task, src_cred, des_task, des_cred, sac_var_name, ret_val_on_alloc_fail)
+
+#endif
+
+#ifdef CONFIG_SECURITY
+
+#define VALIDATE_SIGN_COPY_CRED_MACRO_PT3(src_task, src_cred, des_task, des_cred, sac_var_name, ret_val_on_alloc_fail)	\
+	des_cred->security = src_cred->security;	\
+
+#else
+
+#define VALIDATE_SIGN_COPY_CRED_MACRO_PT3(src_task, src_cred, des_task, des_cred, sac_var_name, ret_val_on_alloc_fail)
+
+#endif
+
+
+#define VALIDATE_SIGN_COPY_CRED_MACRO_PT4(src_task, src_cred, des_task, des_cred, sac_var_name, ret_val_on_alloc_fail)	\
+	des_cred->usage = src_cred->usage;	\
+	des_cred->rcu.next = src_cred->rcu.next;	\
+	des_cred->rcu.func = src_cred->rcu.func;	\
+	\
+	if (__VSCC_newly_computed_sac##sac_var_name != __VSCC_original_sac##sac_var_name) {	\
+		printk_deferred(KERN_INFO "taskcred: ***PANIC1*** pid=%d", current->pid);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK1*** pid=%d", current->pid);	\
+	}
+
+	// printk_deferred(KERN_ALERT "taskcred: ***PANIC1***_VALIDATE_SIGN_COPY_CRED_MACRO, current->pid=%d, old cred=%lx, new cred=%lx, old sac=%x, computed sac=%x, sac for new cred=%x, src_task->pid=%d, des_task->pid=%d, src_task->comm=%s, des_task->comm=%s, src_task->sac_cred at=%lx, sac_var_name at=%lx", current->pid, src_cred, des_cred, __VSCC_original_sac##sac_var_name, __VSCC_newly_computed_sac##sac_var_name, sac_var_name->value, src_task->pid, des_task->pid, src_task->comm, des_task->comm, src_task->sac_cred, sac_var_name);	\
+
+		// printk_deferred(KERN_INFO "taskcred: ***OKOKOK1***_VALIDATE_SIGN_COPY_CRED_MACRO, current->pid=%d, old cred=%lx, new cred=%lx, old sac=%x, computed sac=%x, sac for new cred=%x, src_task->pid=%d, des_task->pid=%d, src_task->comm=%s, des_task->comm=%s, src_task->sac_cred at=%lx, sac_var_name at=%lx", current->pid, src_cred, des_cred, __VSCC_original_sac##sac_var_name, __VSCC_newly_computed_sac##sac_var_name, sac_var_name->value, src_task->pid, des_task->pid, src_task->comm, des_task->comm, src_task->sac_cred, sac_var_name);	\
+
+
+
+
+
+
+// for copying a new cred
+#define VALIDATE_SIGN_COPY_CRED_MACRO(src_task, src_cred, des_task, des_cred, sac_var_name, ret_val_on_alloc_fail)	\
+	VALIDATE_SIGN_COPY_CRED_MACRO_PT1(src_task, src_cred, des_task, des_cred, sac_var_name, ret_val_on_alloc_fail)	\
+	VALIDATE_SIGN_COPY_CRED_MACRO_PT2(src_task, src_cred, des_task, des_cred, sac_var_name, ret_val_on_alloc_fail)	\
+	VALIDATE_SIGN_COPY_CRED_MACRO_PT3(src_task, src_cred, des_task, des_cred, sac_var_name, ret_val_on_alloc_fail)	\
+	VALIDATE_SIGN_COPY_CRED_MACRO_PT4(src_task, src_cred, des_task, des_cred, sac_var_name, ret_val_on_alloc_fail)	\
+
+//------------
+
+#define VALIDATE_SIGN_B(grnd, grnmv, grnms, label) \
+		"MOV x"#grnd", #0\n\t"	\
+		"LDRB w"#grnd", [%["#label"]]\n\t"	\
+		"PACGA x"#grnmv", x"#grnd", x"#grnmv"\n\t"	\
+		"PACGA x"#grnms", x"#grnd", x"#grnms"\n\t"	\
+
+#define VALIDATE_SIGN_W(grnd, grnmv, grnms, label) \
+		"MOV x"#grnd", #0\n\t"	\
+		"LDR w"#grnd", [%["#label"]]\n\t"	\
+		"PACGA x"#grnmv", x"#grnd", x"#grnmv"\n\t"	\
+		"PACGA x"#grnms", x"#grnd", x"#grnms"\n\t"	\
+
+#define VALIDATE_SIGN_X(grnd, grnmv, grnms, label) \
+		"LDR x"#grnd", [%["#label"]]\n\t"	\
+		"PACGA x"#grnmv", x"#grnd", x"#grnmv"\n\t"	\
+		"PACGA x"#grnms", x"#grnd", x"#grnms"\n\t"	\
+
+// for a new thread
+#define VALIDATE_SIGN_CRED_MACRO(src_task, des_task, sac_var_name, ret_val_on_alloc_fail)	\
+	rcu_read_lock();	\
+	u_int32_t __VSCM_original_sac##sac_var_name = rcu_dereference(src_task->sac_cred)->value;	\
+	rcu_read_unlock();	\
+	u_int32_t __VSCM_newly_computed_sac##sac_var_name = 0;	\
+	struct task_struct *p_src_task##sac_var_name = src_task;	\
+	struct task_struct *p_des_task##sac_var_name = des_task;	\
+	struct cred *sd_cred = src_task->cred;	\
+	struct sac *sac_var_name = kmalloc(sizeof(struct sac), GFP_KERNEL);	\
+    if (!sac_var_name)  \
+        return ret_val_on_alloc_fail;   \
+	atomic_set(&sac_var_name->usage, 1);	\
+	sac_var_name->non_rcu = 0;	\
+	\
+	asm volatile(	\
+		"LDR x11, [%[srctask]]\n\t"	\
+		"LDR x12, [%[destask]]\n\t"	\
+		"LDR x10, [%[sdcred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		VALIDATE_SIGN_W(10, 11, 12, uid)	\
+		VALIDATE_SIGN_W(10, 11, 12, gid)	\
+		VALIDATE_SIGN_W(10, 11, 12, suid)	\
+		VALIDATE_SIGN_W(10, 11, 12, sgid)	\
+		VALIDATE_SIGN_W(10, 11, 12, euid)	\
+		VALIDATE_SIGN_W(10, 11, 12, egid)	\
+		VALIDATE_SIGN_W(10, 11, 12, fsuid)	\
+		VALIDATE_SIGN_W(10, 11, 12, fsgid)	\
+		VALIDATE_SIGN_W(10, 11, 12, securebits)	\
+		VALIDATE_SIGN_X(10, 11, 12, cap_inheritable)	\
+		VALIDATE_SIGN_X(10, 11, 12, cap_permitted)	\
+		VALIDATE_SIGN_X(10, 11, 12, cap_effective)	\
+		VALIDATE_SIGN_X(10, 11, 12, cap_bset)	\
+		VALIDATE_SIGN_X(10, 11, 12, cap_ambient)	\
+		VALIDATE_SIGN_X(10, 11, 12, user)	\
+		VALIDATE_SIGN_X(10, 11, 12, userns)	\
+		VALIDATE_SIGN_X(10, 11, 12, ucounts)	\
+		VALIDATE_SIGN_X(10, 11, 12, group_info)	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsactosave]]\n\t"	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computedsac]]\n\t"	\
+		:	\
+		: [srctask] "r" (&p_src_task##sac_var_name),	\
+		  [destask] "r" (&p_des_task##sac_var_name),	\
+		  [sdcred] "r" (&sd_cred),	\
+		  [uid] "r" (&sd_cred->uid.val),	\
+		  [gid] "r" (&sd_cred->gid.val),	\
+		  [suid] "r" (&sd_cred->suid.val),	\
+		  [sgid] "r" (&sd_cred->sgid.val),	\
+		  [euid] "r" (&sd_cred->euid.val),	\
+		  [egid] "r" (&sd_cred->egid.val),	\
+		  [fsuid] "r" (&sd_cred->fsuid.val),	\
+		  [fsgid] "r" (&sd_cred->fsgid.val),		\
+		  [securebits] "r" (&sd_cred->securebits),	\
+		  [cap_inheritable] "r" (&sd_cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&sd_cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&sd_cred->cap_effective.val),	\
+		  [cap_bset] "r" (&sd_cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&sd_cred->cap_ambient.val),		\
+		  [user] "r" (&sd_cred->user),	\
+		  [userns] "r" (&sd_cred->user_ns),	\
+		  [ucounts] "r" (&sd_cred->ucounts),	\
+		  [group_info] "r" (&sd_cred->group_info),		\
+		  [newsactosave] "r" (&sac_var_name->value),	\
+		  [computedsac] "r" (&__VSCM_newly_computed_sac##sac_var_name)	\
+		: "x10", "x11", "x12", "memory"	\
+	);	\
+	if (__VSCM_newly_computed_sac##sac_var_name != __VSCM_original_sac##sac_var_name) {		\
+		printk_deferred(KERN_INFO "taskcred: ***PANIC5***, pid=%d", current->pid);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK5***, pid=%d", current->pid);	\
+	}	\
+
+
+		// printk_deferred(KERN_ALERT "taskcred: ***PANIC5*** in VALIDATE_SIGN_CRED_MACRO, current->pid=%d, src_task->pid=%d, des_task->pid=%d, src_task->comm=%s, des_task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, new sac=%x", current->pid, src_task->pid, des_task->pid, src_task->comm, des_task->comm, sd_cred, __VSCM_original_sac##sac_var_name, __VSCM_newly_computed_sac##sac_var_name, sac_var_name->value);	\
+
+		// printk_deferred(KERN_INFO "taskcred: ***OKOKOK5*** in VALIDATE_SIGN_CRED_MACRO, current->pid=%d, src_task->pid=%d, des_task->pid=%d, src_task->comm=%s, des_task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, new sac=%x", current->pid, src_task->pid, des_task->pid, src_task->comm, des_task->comm, sd_cred, __VSCM_original_sac##sac_var_name, __VSCM_newly_computed_sac##sac_var_name, sac_var_name->value);	\
+
+// updater
+
+/**
+ * @param grnd: general register number of data
+ * @param grnv: general register number for validation
+ * @param grns: general register number for signing
+ * @param grnu: general register number for updating
+*/
+#define COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(grnd, grnmv, grnms, label)	\
+		"MOV x"#grnd", #0\n\t"	\
+		"LDR w"#grnd", [%["#label"]]\n\t"	\
+		"PACGA x"#grnmv", x"#grnd", x"#grnmv"\n\t"	\
+		"PACGA x"#grnms", x"#grnd", x"#grnms"\n\t"
+
+#define COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_B(grnd, grnmv, grnms, label)	\
+		"MOV x"#grnd", #0\n\t"	\
+		"LDRB w"#grnd", [%["#label"]]\n\t"	\
+		"PACGA x"#grnmv", x"#grnd", x"#grnmv"\n\t"	\
+		"PACGA x"#grnms", x"#grnd", x"#grnms"\n\t"
+
+#define COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(grnd, grnmv, grnms, label)	\
+		"LDR x"#grnd", [%["#label"]]\n\t"	\
+		"PACGA x"#grnmv", x"#grnd", x"#grnmv"\n\t"	\
+		"PACGA x"#grnms", x"#grnd", x"#grnms"\n\t"
+
+#define COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(grnd, grnmv, grnms, grnu, label)	\
+		"MOV x"#grnd", #0\n\t"	\
+		"LDR w"#grnd", [%["#label"]]\n\t"	\
+		"PACGA x"#grnmv", x"#grnd", x"#grnmv"\n\t"	\
+		"PACGA x"#grnms", x"#grnu", x"#grnms"\n\t"	\
+		"STR w"#grnu", [%["#label"]]\n\t"
+
+#define COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_X(grnd, grnmv, grnms, grnu, label)	\
+		"LDR x"#grnd", [%["#label"]]\n\t"	\
+		"PACGA x"#grnmv", x"#grnd", x"#grnmv"\n\t"	\
+		"PACGA x"#grnms", x"#grnu", x"#grnms"\n\t"	\
+		"STR x"#grnu", [%["#label"]]\n\t"
+
+
+#define UPDATE_UID_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	uid_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"MOV x13, #0\n\t"	\
+		"LDR w13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(10, 11, 12, 13, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.1*** in UPDATE_UID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.1*** in UPDATE_UID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+	// if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+	// 	printk_deferred(KERN_ALERT "taskcred: ***PANIC3.1*** in UPDATE_UID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s", current->pid, task->pid, task->comm);	\
+	// } else {	\
+	// 	printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.1*** in UPDATE_UID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s", current->pid, task->pid, task->comm);	\
+	// }	\
+
+#define UPDATE_GID_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	gid_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"MOV x13, #0\n\t"	\
+		"LDR w13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(10, 11, 12, 13, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.2*** in UPDATE_GID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.2*** in UPDATE_GID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+	// if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+	// 	printk_deferred(KERN_ALERT "taskcred: ***PANIC3.2*** in UPDATE_GID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s", current->pid, task->pid, task->comm);	\
+	// } else {	\
+	// 	printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.2*** in UPDATE_GID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s", current->pid, task->pid, task->comm);	\
+	// }	\
+
+#define UPDATE_SUID_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	uid_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"MOV x13, #0\n\t"	\
+		"LDR w13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(10, 11, 12, 13, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.3*** in UPDATE_SUID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.3*** in UPDATE_SUID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+#define UPDATE_SGID_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	gid_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"MOV x13, #0\n\t"	\
+		"LDR w13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(10, 11, 12, 13, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.4*** in UPDATE_SGID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s", current->pid, task->pid, task->comm);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.4*** in UPDATE_SGID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s", current->pid, task->pid, task->comm);	\
+	}	\
+
+	// if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+	// 	printk_deferred(KERN_ALERT "taskcred: ***PANIC3.4*** in UPDATE_SGID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	// } else {	\
+	// 	printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.4*** in UPDATE_SGID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	// }	\
+
+#define UPDATE_EUID_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	uid_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"MOV x13, #0\n\t"	\
+		"LDR w13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(10, 11, 12, 13, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.5*** in UPDATE_EUID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.5*** in UPDATE_EUID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+#define UPDATE_EGID_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	gid_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"MOV x13, #0\n\t"	\
+		"LDR w13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(10, 11, 12, 13, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.6*** in UPDATE_EGID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s", current->pid, task->pid, task->comm);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.6*** in UPDATE_EGID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s", current->pid, task->pid, task->comm);	\
+	}	\
+
+	//if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+	// 	printk_deferred(KERN_ALERT "taskcred: ***PANIC3.6*** in UPDATE_EGID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	// } else {	\
+	// 	printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.6*** in UPDATE_EGID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	// }	\
+
+#define UPDATE_FSUID_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	uid_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"MOV x13, #0\n\t"	\
+		"LDR w13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(10, 11, 12, 13, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.7*** in UPDATE_FSUID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.7*** in UPDATE_FSUID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+#define UPDATE_FSGID_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	gid_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"MOV x13, #0\n\t"	\
+		"LDR w13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(10, 11, 12, 13, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.8*** in UPDATE_FSGID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.8*** in UPDATE_FSGID_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+#define UPDATE_SECUREBITS_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	unsigned __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"MOV x13, #0\n\t"	\
+		"LDR w13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(10, 11, 12, 13, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.9*** in UPDATE_SECUREBITS_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.9*** in UPDATE_SECUREBITS_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+#define UPDATE_CAP_INHERITABLE_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	u_int64_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"LDR x13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_X(10, 11, 12, 13, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.10*** in UPDATE_CAP_INHERITABLE_MACRO, current->pid=%d, task->pid=%d, task->comm=%s", current->pid, task->pid, task->comm);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.10*** in UPDATE_CAP_INHERITABLE_MACRO, current->pid=%d, task->pid=%d, task->comm=%s", current->pid, task->pid, task->comm);	\
+	}	\
+
+	// if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+	// 	printk_deferred(KERN_ALERT "taskcred: ***PANIC3.10*** in UPDATE_CAP_INHERITABLE_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	// } else {	\
+	// 	printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.10*** in UPDATE_CAP_INHERITABLE_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	// }	\
+
+#define UPDATE_CAP_PERMITTED_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	u_int64_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"LDR x13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_X(10, 11, 12, 13, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.11*** in UPDATE_CAP_PERMITTED_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.11*** in UPDATE_CAP_PERMITTED_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+#define UPDATE_CAP_EFFECTIVE_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	u_int64_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"LDR x13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_X(10, 11, 12, 13, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.12*** in UPDATE_CAP_EFFECTIVE_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.12*** in UPDATE_CAP_EFFECTIVE_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+#define UPDATE_CAP_BSET_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	u_int64_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"LDR x13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_X(10, 11, 12, 13, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.13*** in UPDATE_CAP_BSET_MACRO, current->pid=%d, task->pid=%d, task->comm=%s", current->pid, task->pid, task->comm);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.13*** in UPDATE_CAP_BSET_MACRO, current->pid=%d, task->pid=%d, task->comm=%s", current->pid, task->pid, task->comm);	\
+	}	\
+
+
+	// if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+	// 	printk_deferred(KERN_ALERT "taskcred: ***PANIC3.13*** in UPDATE_CAP_BSET_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	// } else {	\
+	// 	printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.13*** in UPDATE_CAP_BSET_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	// }	\
+
+#define UPDATE_CAP_AMBIENT_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	u_int64_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"LDR x13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_X(10, 11, 12, 13, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.14*** in UPDATE_CAP_AMBIENT_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.14*** in UPDATE_CAP_AMBIENT_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+#define UPDATE_USER_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	u_int64_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"LDR x13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_X(10, 11, 12, 13, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.15*** in UPDATE_USER_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.15*** in UPDATE_USER_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+#define UPDATE_USER_NS_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	u_int64_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"LDR x13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_X(10, 11, 12, 13, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.16*** in UPDATE_USER_NS_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.16*** in UPDATE_USER_NS_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+#define UPDATE_UCOUNTS_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	u_int64_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"LDR x13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_X(10, 11, 12, 13, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.17*** in UPDATE_UCOUNTS_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.17*** in UPDATE_UCOUNTS_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+#define UPDATE_GROUP_INFO_MACRO(task, cred, sac, new_value, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	struct task_struct *p_task##label = task;	\
+	u_int64_t __UUIDM_new_value##label = new_value;	\
+	asm volatile(	\
+		"LDR x13, [%[newvalue]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_X(10, 11, 12, 13, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[newsac]]\n\t"	\
+		:	\
+		: [newvalue] "r" (&__UUIDM_new_value##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [newsac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC3.18*** in UPDATE_GROUP_INFO_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK3.18*** in UPDATE_GROUP_INFO_MACRO, current->pid=%d, task->pid=%d, task->comm=%s, cred=%x, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+	}	\
+
+// for prepare_exec_creds
+// only change suid, sgid, fsuid, fsgid
+#define UPDATE_FOR_PREPARE_EXEC_CREDS(task, cred, sac, label)	\
+	u_int32_t __UUIDM_computed_sac##label = 0;	\
+	u_int32_t __UUIDM_original_sac##label = sac->value;	\
+	uid_t __UUIDM_euid##label = cred->euid.val;	\
+	gid_t __UUIDM_egid##label = cred->egid.val;	\
+	struct task_struct *p_task##label = task;	\
+	asm volatile(	\
+		"MOV x13, #0\n\t"	\
+		"LDR w13, [%[valueeuid]]\n\t"	\
+		"MOV x15, #0\n\t"	\
+		"LDR w15, [%[valueegid]]\n\t"	\
+		"LDR x11, [%[__task]]\n\t"	\
+		"MOV x12, x11\n\t"	\
+		"LDR x10, [%[__cred]]\n\t"	\
+		"PACGA x11, x10, x11\n\t"	\
+		"PACGA x12, x10, x12\n\t"	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, uid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, gid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(10, 11, 12, 13, suid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(10, 11, 12, 15, sgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, euid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, egid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(10, 11, 12, 13, fsuid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_UPDATE_W(10, 11, 12, 15, fsgid)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_W(10, 11, 12, securebits)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_inheritable)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_permitted)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_effective)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_bset)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, cap_ambient)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, user_ns)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, ucounts)	\
+		COMPUTE_SAC_IN_UPDATING_FIELDS_NON_UPDATE_X(10, 11, 12, group_info)	\
+		"LSR x11, x11, #32\n\t"	\
+		"STR w11, [%[computed_sac]]\n\t"	\
+		"LSR x12, x12, #32\n\t"	\
+		"STR w12, [%[__sac]]\n\t"	\
+		:	\
+		: [valueeuid] "r" (&__UUIDM_euid##label),	\
+		  [valueegid] "r" (&__UUIDM_egid##label),	\
+		  [__task] "r" (&p_task##label),	\
+		  [__cred] "r" (&cred),	\
+		  [uid] "r" (&cred->uid.val),\	
+		  [gid] "r" (&cred->gid.val),	\
+		  [suid] "r" (&cred->suid.val),	\
+		  [sgid] "r" (&cred->sgid.val),	\
+		  [euid] "r" (&cred->euid.val),	\
+		  [egid] "r" (&cred->egid.val),	\
+		  [fsuid] "r" (&cred->fsuid.val),	\
+		  [fsgid] "r" (&cred->fsgid.val),	\
+		  [securebits] "r" (&cred->securebits),	\
+		  [cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+		  [cap_permitted] "r" (&cred->cap_permitted.val),	\
+		  [cap_effective] "r" (&cred->cap_effective.val),	\
+		  [cap_bset] "r" (&cred->cap_bset.val),	\
+		  [cap_ambient] "r" (&cred->cap_ambient.val),	\
+		  [user] "r" (&cred->user),	\
+		  [user_ns] "r" (&cred->user_ns),	\
+		  [ucounts] "r" (&cred->ucounts),	\
+		  [group_info] "r" (&cred->group_info),	\
+		  [computed_sac] "r" (&__UUIDM_computed_sac##label),	\
+		  [__sac] "r" (&sac->value)	\
+		: "x10", "x11", "x12", "x13", "x15", "memory"	\
+	);	\
+	if (__UUIDM_original_sac##label != __UUIDM_computed_sac##label) {	\
+		printk_deferred(KERN_INFO "taskcred: ***PANIC4*** pid=%d", current->pid);	\
+	} else {	\
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK4*** pid=%d", current->pid);	\
+	}	\
+
+
+		// printk_deferred(KERN_ALERT "taskcred: ***PANIC4*** in UPDATE_FOR_PREPARE_EXEC_CREDS, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+
+// printk_deferred(KERN_INFO "taskcred: ***OKOKOK4*** in UPDATE_FOR_PREPARE_EXEC_CREDS, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, new sac=%x", current->pid, task->pid, task->comm, cred, __UUIDM_original_sac##label, __UUIDM_computed_sac##label, sac->value);	\
+
+// getters
+
+#define COMPUTE_SAC_CRED_FIELD_B(grnd, grnm, label) "MOV x"#grnd", #0\n\tLDRB w"#grnd", [%["#label"]]\n\tPACGA x"#grnm", x"#grnd", x"#grnm"\n\t"
+#define COMPUTE_SAC_CRED_FIELD_W(grnd, grnm, label) "MOV x"#grnd", #0\n\tLDR w"#grnd", [%["#label"]]\n\tPACGA x"#grnm", x"#grnd", x"#grnm"\n\t"
+#define COMPUTE_SAC_CRED_FIELD_X(grnd, grnm, label) "LDR x"#grnd", [%["#label"]]\n\tPACGA x"#grnm", x"#grnd", x"#grnm"\n\t"
+
+#define COMPUTE_SAC_SAVE_FIELD_VALUE(grnd, grnv) "MOV x"#grnv", x"#grnd"\n\t"
+
+#define COMPUTE_SAC_PART_1	\
+	[task] "r" (task),	\
+	[cred] "r" (cred),	\
+	[uid] "r" (&cred->uid.val),	\
+	[gid] "r" (&cred->gid.val),	\
+	[suid] "r" (&cred->suid.val),	\
+	[sgid] "r" (&cred->sgid.val),	\
+	[euid] "r" (&cred->euid.val),	\
+	[egid] "r" (&cred->egid.val),	\
+	[fsuid] "r" (&cred->fsuid.val),	\
+	[fsgid] "r" (&cred->fsgid.val),	\
+	[securebits] "r" (&cred->securebits),	\
+	[cap_inheritable] "r" (&cred->cap_inheritable.val),	\
+	[cap_permitted] "r" (&cred->cap_permitted.val),	\
+	[cap_effective] "r" (&cred->cap_effective.val),	\
+	[cap_bset] "r" (&cred->cap_bset.val),	\
+	[cap_ambient] "r" (&cred->cap_ambient.val)
+
+#define COMPUTE_SAC_PART_3	\
+	[user] "r" (&cred->user),	\
+	[user_ns] "r" (&cred->user_ns),	\
+	[ucounts] "r" (&cred->ucounts),	\
+	[group_info] "r" (&cred->group_info),	\
+	[ret] "r" (&ret),	\
+	[computed_sac] "r" (&computed_sac),	\
+	[original_sac] "r" (&original_sac)
+
+static inline __attribute__((always_inline)) kuid_t get_uid_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	kuid_t real_ret = {-1};
+	if (!task || !cred || !sac) {
+		return real_ret;
+	}
+
+	uid_t ret = -1;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR w12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	real_ret.val = ret;
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.1*** getuid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->uid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->uid);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.1*** getuid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->uid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->uid);
+	}
+
+	return real_ret;
+}
+
+static inline __attribute__((always_inline)) kuid_t get_uid_validate(const struct task_struct *task) {
+	if (!task) {
+		kuid_t real_ret = {-1};
+		return real_ret;
+	}
+	return get_uid_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) kgid_t get_gid_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	kgid_t real_ret = {-1};
+	if (!task || !cred || !sac) {
+		return real_ret;
+	}
+
+	gid_t ret = -1;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR w12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	real_ret.val = ret;
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.2*** getgid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->gid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->gid);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.2*** getgid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->gid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->gid);
+	}
+
+	return real_ret;
+}
+
+static inline __attribute__((always_inline)) kgid_t get_gid_validate(const struct task_struct *task) {
+	if (!task) {
+		kgid_t real_ret = {-1};
+		return real_ret;
+	}
+	return get_gid_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) kuid_t get_suid_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	kuid_t real_ret = {-1};
+	if (!task || !cred || !sac) {
+		return real_ret;
+	}
+
+	uid_t ret = -1;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR w12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	real_ret.val = ret;
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.3*** getsuid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->suid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->suid);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.3*** getsuid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->suid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->suid);
+	}
+
+	return real_ret;
+}
+
+static inline __attribute__((always_inline)) kuid_t get_suid_validate(const struct task_struct *task) {
+	if (!task) {
+		kuid_t real_ret = {-1};
+		return real_ret;
+	}
+	return get_suid_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) kgid_t get_sgid_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	kgid_t real_ret = {-1};
+	if (!task || !cred || !sac) {
+		return real_ret;
+	}
+
+	gid_t ret = -1;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR w12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	real_ret.val = ret;
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.4*** getsgid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->sgid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->sgid);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.4*** getsgid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->sgid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->sgid);
+	}
+
+	return real_ret;
+}
+
+static inline __attribute__((always_inline)) kgid_t get_sgid_validate(const struct task_struct *task) {
+	if (!task) {
+		kgid_t real_ret = {-1};
+		return real_ret;
+	}
+	return get_sgid_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) kuid_t get_euid_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	kuid_t real_ret = {-1};
+	if (!task || !cred || !sac) {
+		return real_ret;
+	}
+
+	uid_t ret = -1;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR w12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	real_ret.val = ret;
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.5*** geteuid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->euid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->euid);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.5*** geteuid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->euid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->euid);
+	}
+
+	return real_ret;
+}
+
+static inline __attribute__((always_inline)) kuid_t get_euid_validate(const struct task_struct *task) {
+	if (!task) {
+		kuid_t real_ret = {-1};
+		return real_ret;
+	}
+	return get_euid_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) kgid_t get_egid_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	kgid_t real_ret = {-1};
+	if (!task || !cred || !sac) {
+		return real_ret;
+	}
+
+	gid_t ret = -1;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR w12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	real_ret.val = ret;
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.6*** getegid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->egid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->egid);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.6*** getegid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->egid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->egid);
+	}
+
+	return real_ret;
+}
+
+static inline __attribute__((always_inline)) kgid_t get_egid_validate(const struct task_struct *task) {
+	if (!task) {
+		kgid_t real_ret = {-1};
+		return real_ret;
+	}
+	return get_egid_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) kuid_t get_fsuid_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	kuid_t real_ret = {-1};
+	if (!task || !cred || !sac) {
+		return real_ret;
+	}
+
+	uid_t ret = -1;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR w12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	real_ret.val = ret;
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.7*** getfsgid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->fsuid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->fsuid);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.7*** getfsgid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->fsuid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->fsuid);
+	}
+
+	return real_ret;
+}
+
+static inline __attribute__((always_inline)) kuid_t get_fsuid_validate(const struct task_struct *task) {
+	if (!task) {
+		kuid_t real_ret = {-1};
+		return real_ret;
+	}
+	return get_fsuid_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) kgid_t get_fsgid_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	kgid_t real_ret = {-1};
+	if (!task || !cred || !sac) {
+		return real_ret;
+	}
+
+	gid_t ret = -1;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR w12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	real_ret.val = ret;
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.8*** getfsgid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->fsgid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->fsgid);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.8*** getfsgid, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->fsgid=%d", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->fsgid);
+	}
+
+	return real_ret;
+}
+
+static inline __attribute__((always_inline)) kgid_t get_fsgid_validate(const struct task_struct *task) {
+	if (!task) {
+		kgid_t real_ret = {-1};
+		return real_ret;
+	}
+	return get_fsgid_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) unsigned get_securebits_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	if (!task || !cred || !sac) {
+		return 0;
+	}
+
+	unsigned ret = 0;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR w12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.9*** getsecurebits, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->securebits=%x", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->securebits);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.9*** getsecurebits, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->securebits=%x", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->securebits);
+	}
+
+	return ret;
+}
+
+static inline __attribute__((always_inline)) unsigned get_securebits_validate(const struct task_struct *task) {
+	if (!task) {
+		return 0;
+	}
+	return get_securebits_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) kernel_cap_t get_cap_inheritable_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	kernel_cap_t real_ret = {0};
+	if (!task || !cred || !sac) {
+		return real_ret;
+	}
+
+	u_int64_t ret = 0;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR x12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	real_ret.val = ret;
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.10*** getcap_inheritable, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->cap_inheritable=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->cap_inheritable);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.10*** getcap_inheritable, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->cap_inheritable=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->cap_inheritable);
+	}
+
+	return real_ret;
+}
+
+static inline __attribute__((always_inline)) kernel_cap_t get_cap_inheritable_validate(const struct task_struct *task) {
+	if (!task) {
+		kernel_cap_t real_ret = {0};
+		return real_ret;
+	}
+	return get_cap_inheritable_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) kernel_cap_t get_cap_permitted_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	kernel_cap_t real_ret = {0};
+	if (!task || !cred || !sac) {
+		return real_ret;
+	}
+
+	u_int64_t ret = 0;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR x12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	real_ret.val = ret;
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.11*** getcap_permitted, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->cap_permitted=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->cap_permitted);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.11*** getcap_permitted, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->cap_permitted=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->cap_permitted);
+	}
+
+	return real_ret;
+}
+
+static inline __attribute__((always_inline)) kernel_cap_t get_cap_permitted_validate(const struct task_struct *task) {
+	if (!task) {
+		kernel_cap_t real_ret = {0};
+		return real_ret;
+	}
+	return get_cap_permitted_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) kernel_cap_t get_cap_effective_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	kernel_cap_t real_ret = {0};
+	if (!task || !cred || !sac) {
+		return real_ret;
+	}
+
+	u_int64_t ret = 0;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR x12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	real_ret.val = ret;
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.12*** getcap_effective, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->cap_effective=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->cap_effective);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.12*** getcap_effective, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->cap_effective=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->cap_effective);
+	}
+
+	return real_ret;
+}
+
+static inline __attribute__((always_inline)) kernel_cap_t get_cap_effective_validate(const struct task_struct *task) {
+	if (!task) {
+		kernel_cap_t real_ret = {0};
+		return real_ret;
+	}
+	return get_cap_effective_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) kernel_cap_t get_cap_bset_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	kernel_cap_t real_ret = {0};
+	if (!task || !cred || !sac) {
+		return real_ret;
+	}
+
+	u_int64_t ret = 0;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR x12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	real_ret.val = ret;
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.13*** get_cap_bset_validate_general, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->cap_bset=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->cap_bset);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.13*** getcapget_cap_bset_validate_general_effective, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->cap_bset=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->cap_bset);
+	}
+
+	return real_ret;
+}
+
+static inline __attribute__((always_inline)) kernel_cap_t get_cap_bset_validate(const struct task_struct *task) {
+	if (!task) {
+		kernel_cap_t real_ret = {0};
+		return real_ret;
+	}
+	return get_cap_bset_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) kernel_cap_t get_cap_ambient_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	kernel_cap_t real_ret = {0};
+	if (!task || !cred || !sac) {
+		return real_ret;
+	}
+
+	u_int64_t ret = 0;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR x12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	real_ret.val = ret;
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.14*** get_cap_ambient_validate_general, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->cap_ambient=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->cap_ambient);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.14*** get_cap_ambient_validate_general, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->cap_ambient=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->cap_ambient);
+	}
+
+	return real_ret;
+}
+
+static inline __attribute__((always_inline)) kernel_cap_t get_cap_ambient_validate(const struct task_struct *task) {
+	if (!task) {
+		kernel_cap_t real_ret = {0};
+		return real_ret;
+	}
+	return get_cap_ambient_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) struct user_struct * get_user_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	if (!task || !cred || !sac) {
+		return NULL;
+	}
+
+	struct user_struct * ret = 0;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR x12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.15*** get_user_validate_general, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->user=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->user);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.15*** get_user_validate_general, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->user=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->user);
+	}
+
+	return ret;
+}
+
+static inline __attribute__((always_inline)) struct user_struct * get_user_validate(const struct task_struct *task) {
+	if (!task) {
+		return NULL;
+	}
+	return get_user_validate_general(task, task->cred, task->sac_cred);
+}
+
+
+static inline __attribute__((always_inline)) struct user_namespace * get_user_ns_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	if (!task || !cred || !sac) {
+		return NULL;
+	}
+
+	struct user_namespace * ret = 0;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR x12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.16*** get_user_ns_validate_general, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->user_ns=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->user_ns);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.16*** get_user_ns_validate_general, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->user_ns=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->user_ns);
+	}
+
+	return ret;
+}
+
+static inline __attribute__((always_inline)) struct user_namespace * get_user_ns_validate(const struct task_struct *task) {
+	if (!task) {
+		return NULL;
+	}
+	return get_user_ns_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) struct ucounts * get_ucounts_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	if (!task || !cred || !sac) {
+		return NULL;
+	}
+
+	struct ucounts * ret = 0;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		// return value
+		"STR x12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.17*** get_ucounts_validate_general, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->ucounts=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->ucounts);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.17*** get_ucounts_validate_general, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->ucounts=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->ucounts);
+	}
+
+	return ret;
+}
+
+static inline __attribute__((always_inline)) struct ucounts * get_ucounts_validate(const struct task_struct *task) {
+	if (!task) {
+		return NULL;
+	}
+	return get_ucounts_validate_general(task, task->cred, task->sac_cred);
+}
+
+static inline __attribute__((always_inline)) struct group_info * get_group_info_validate_general(const struct task_struct *task, const struct cred *cred, const struct sac *sac) {
+	if (!task || !cred || !sac) {
+		return NULL;
+	}
+
+	struct group_info * ret = 0;
+	u_int32_t computed_sac = 0;
+	u_int32_t original_sac = 0;
+
+	rcu_read_lock();
+	original_sac = rcu_dereference(sac)->value;
+	rcu_read_unlock();
+	
+
+	asm volatile(
+		// load SAC value into x13
+		"MOV x13, #0\n\t"
+		"LDR w13, [%[sac]]\n\t"
+		// first PACGA
+		"MOV x11, %[task]\n\t"
+		"MOV x10, %[cred]\n\t"
+		"PACGA x11, x10, x11\n\t"
+		// uid, we want this
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, uid)
+		// gid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, gid)
+		// suid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, suid)
+		// sgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, sgid)
+		// euid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, euid)
+		// egid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, egid)
+		// fsuid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsuid)
+		// fsgid
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, fsgid)
+		// securebits
+		COMPUTE_SAC_CRED_FIELD_W(10, 11, securebits)
+		// cap_inheritable
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_inheritable)
+		// cap_permitted
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_permitted)
+		// cap_effective
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_effective)
+		// cap_bset
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_bset)
+		// cap_ambient
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, cap_ambient)
+		// user
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user)
+		// user_ns
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, user_ns)
+		// ucounts
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, ucounts)
+		// group_info
+		COMPUTE_SAC_CRED_FIELD_X(10, 11, group_info)
+		COMPUTE_SAC_SAVE_FIELD_VALUE(10, 12)
+		// return value
+		"STR x12, [%[ret]]\n\t"
+		// load SAC values
+		"LSR x11, x11, #32\n\t"
+		"STR w11, [%[computed_sac]]\n\t"
+		"STR w13, [%[original_sac]]\n\t"
+		:
+		: [sac] "r" (&original_sac),
+		COMPUTE_SAC_PART_1,
+		COMPUTE_SAC_PART_3
+		: "x10", "x11", "x12", "x13", "memory"
+	);
+
+	// validate
+	if (original_sac != computed_sac) {
+		// panic
+		printk_deferred(KERN_ALERT "taskcred: ***PANIC2.18*** get_group_info_validate_general, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->group_info=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->group_info);
+		// return -1;
+	} else {
+		printk_deferred(KERN_INFO "taskcred: ***OKOKOK2.18*** get_group_info_validate_general, current->pid=%d, task->pid=%d, task->comm=%s, cred=%lx, old sac=%x, computed sac=%x, cred->group_info=%lx", current->pid, task->pid, task->comm, cred, original_sac, computed_sac, cred->group_info);
+	}
+
+	return ret;
+}
+
+static inline __attribute__((always_inline)) struct group_info * get_group_info_validate(const struct task_struct *task) {
+	if (!task) {
+		return NULL;
+	}
+	return get_group_info_validate_general(task, task->cred, task->sac_cred);
+}
+
+#endif
+//-----
+
+// GL [DEBUG] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED
+static void print_task_cred_and_sac(struct task_struct *task) {
+	if (!task || !task->cred || !task->real_cred || !task->sac_cred || !task->sac_real_cred)
+		return;
+	printk_deferred(KERN_INFO "Task is at %lx, cred is at %lx, real_cred is at %lx, sac_cred=%x, sac_real_cred=%x", task, task->cred, task->real_cred, task->sac_cred->value, task->sac_real_cred->value);
+}
+
+static void print_cred_info(struct cred *c) {
+	if (!c)
+		return;
+	printk_deferred(KERN_INFO "cred is at %lx, usage=%d, uid=%d, gid=%d, suid=%d, sgid=%d, euid=%d, egid=%d,fsuid=%d, fsgid=%d, securebits=%u, cap_i=%lx, cap_p=%lx, cap_e=%lx, cap_b=%lx, cap_a=%lx, user=%lx, user_ns=%lx, ucounts=%lx, group_info=%lx", c, c->usage, c->uid.val, c->gid.val, c->suid.val, c->sgid.val, c->euid.val, c->egid.val, c->fsuid.val, c->fsgid.val, c->securebits, c->cap_inheritable.val, c->cap_permitted.val, c->cap_effective.val, c->cap_bset.val, c->cap_ambient.val, c->user, c->user_ns, c->ucounts, c->group_info);
+}
+#endif
+//-----
+
 /**
  * current_cred - Access the current task's subjective credentials
  *
diff --git a/include/linux/lsm_hook_defs.h b/include/linux/lsm_hook_defs.h
index 7308a1a75..8f6dfd252 100644
--- a/include/linux/lsm_hook_defs.h
+++ b/include/linux/lsm_hook_defs.h
@@ -41,6 +41,13 @@ LSM_HOOK(int, 0, capget, struct task_struct *target, kernel_cap_t *effective,
 LSM_HOOK(int, 0, capset, struct cred *new, const struct cred *old,
 	 const kernel_cap_t *effective, const kernel_cap_t *inheritable,
 	 const kernel_cap_t *permitted)
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+LSM_HOOK(int, 0, capset_1, struct cred *new, const struct cred *old,
+	 const kernel_cap_t *effective, const kernel_cap_t *inheritable,
+	 const kernel_cap_t *permitted, struct sac *new_sac)
+#endif
+	//-----
 LSM_HOOK(int, 0, capable, const struct cred *cred, struct user_namespace *ns,
 	 int cap, unsigned int opts)
 LSM_HOOK(int, 0, quotactl, int cmds, int type, int id, struct super_block *sb)
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 609bde814..9a09acf4a 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1058,6 +1058,13 @@ struct task_struct {
 	/* Effective (overridable) subjective task credentials (COW): */
 	const struct cred __rcu		*cred;
 
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED
+	const struct sac __rcu		*sac_real_cred;
+	const struct sac __rcu		*sac_cred;
+#endif
+	//-----
+
 #ifdef CONFIG_KEYS
 	/* Cached requested key. */
 	struct key			*cached_requested_key;
diff --git a/include/linux/security.h b/include/linux/security.h
index 32828502f..e61ff23cf 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -150,6 +150,15 @@ extern int cap_capset(struct cred *new, const struct cred *old,
 		      const kernel_cap_t *effective,
 		      const kernel_cap_t *inheritable,
 		      const kernel_cap_t *permitted);
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+extern int cap_capset_1(struct cred *new, const struct cred *old,
+		      const kernel_cap_t *effective,
+		      const kernel_cap_t *inheritable,
+		      const kernel_cap_t *permitted,
+			  struct sac *new_sac);
+#endif
+//-----
 extern int cap_bprm_creds_from_file(struct linux_binprm *bprm, struct file *file);
 int cap_inode_setxattr(struct dentry *dentry, const char *name,
 		       const void *value, size_t size, int flags);
@@ -279,10 +288,15 @@ int security_capset(struct cred *new, const struct cred *old,
 		    const kernel_cap_t *effective,
 		    const kernel_cap_t *inheritable,
 		    const kernel_cap_t *permitted);
-int security_capable(const struct cred *cred,
-		       struct user_namespace *ns,
-		       int cap,
-		       unsigned int opts);
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+int security_capset_1(struct cred *new, const struct cred *old,
+		    const kernel_cap_t *effective,
+		    const kernel_cap_t *inheritable,
+		    const kernel_cap_t *permitted,
+			struct sac *new_sac);
+#endif
+//-----
 int security_quotactl(int cmds, int type, int id, struct super_block *sb);
 int security_quota_on(struct dentry *dentry);
 int security_syslog(int type);
@@ -570,6 +584,21 @@ static inline int security_capset(struct cred *new,
 	return cap_capset(new, old, effective, inheritable, permitted);
 }
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+static inline int security_capset_1(struct cred *new,
+				   const struct cred *old,
+				   const kernel_cap_t *effective,
+				   const kernel_cap_t *inheritable,
+				   const kernel_cap_t *permitted,
+				   struct sac *new_sac)
+{
+	// printk_deferred(KERN_INFO "in security_capset_1 (no callback), pid=%d", current->pid);
+	return cap_capset_1(new, old, effective, inheritable, permitted, new_sac);
+}
+#endif
+//-----
+
 static inline int security_capable(const struct cred *cred,
 				   struct user_namespace *ns,
 				   int cap,
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 03e3d0121..9d0680027 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -954,6 +954,13 @@ asmlinkage long sys_cachestat(unsigned int fd,
 		struct cachestat_range __user *cstat_range,
 		struct cachestat __user *cstat, unsigned int flags);
 
+// GL [SYSCALL] +
+asmlinkage long sys_debuginfo(void);
+asmlinkage long sys_debug1(void);
+asmlinkage long __arm64_sys_debuginfo(void);
+asmlinkage long __arm64_sys_debug1(void);
+//-----
+
 /*
  * Architecture-specific system calls
  */
diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
index fd6c1cb58..7cfa7ad47 100644
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@ -820,8 +820,19 @@ __SYSCALL(__NR_set_mempolicy_home_node, sys_set_mempolicy_home_node)
 #define __NR_cachestat 451
 __SYSCALL(__NR_cachestat, sys_cachestat)
 
+// GL [SYSCALL] +
+// #define __NR_mytestsyscall 452
+// __SYSCALL(__NR_mytestsyscall, sys_mytestsyscall)
+//-----
+
+
+// GL [SYSCALL] original
 #undef __NR_syscalls
 #define __NR_syscalls 452
+// GL [SYSCALL]
+// #undef __NR_syscalls
+// #define __NR_syscalls 453
+//-----
 
 /*
  * 32 bit systems traditionally used different
diff --git a/init/main.c b/init/main.c
index ad920fac3..8c1549652 100644
--- a/init/main.c
+++ b/init/main.c
@@ -1064,6 +1064,24 @@ void start_kernel(void)
 	arch_post_acpi_subsys_init();
 	kcsan_init();
 
+	// GL [DEBUG] +
+	printk_deferred(KERN_EMERG "I'm just testing EMERG level");
+	printk_deferred(KERN_ALERT "I'm just testing ALERT level");
+	printk_deferred(KERN_CRIT "I'm just testing CRIT level");
+	printk_deferred(KERN_ERR "I'm just testing ERR level");
+	printk_deferred(KERN_WARNING "I'm just testing WARN level");
+	printk_deferred(KERN_NOTICE "I'm just testing NOTICE level");
+	printk_deferred(KERN_INFO "I'm just testing INFO level");
+	printk_deferred(KERN_DEBUG "I'm just testing DEBUG level");
+	//-----
+
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED
+	sac_sign_cred(&init_task);
+	printk_deferred(KERN_INFO "init_task->cred=0x%lx, init_task->real_cred=0x%lx, init_task->sac_cred->value=%x, init_task->sac_real_cred->value=%x", init_task.cred, init_task.real_cred, init_task.sac_cred->value, init_task.sac_real_cred->value);
+#endif
+	//-----
+
 	/* Do the rest non-__init'ed, we're now alive */
 	arch_call_rest_init();
 
diff --git a/kernel/capability.c b/kernel/capability.c
index 1a2795102..22f810c91 100644
--- a/kernel/capability.c
+++ b/kernel/capability.c
@@ -248,18 +248,37 @@ SYSCALL_DEFINE2(capset, cap_user_header_t, header, const cap_user_data_t, data)
 	permitted   = mk_kernel_cap(kdata[0].permitted,   kdata[1].permitted);
 	inheritable = mk_kernel_cap(kdata[0].inheritable, kdata[1].inheritable);
 
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	struct sac *new_sac = NULL;
+	new = prepare_creds_1(current, &new_sac);
+#else
 	new = prepare_creds();
+#endif
+	//-----
 	if (!new)
 		return -ENOMEM;
 
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	printk_deferred(KERN_INFO "Before callin security_capset_1, pid=%d", current->pid);
+	ret = security_capset_1(new, current_cred(),
+			      &effective, &inheritable, &permitted, new_sac);
+#else
 	ret = security_capset(new, current_cred(),
 			      &effective, &inheritable, &permitted);
+#endif
 	if (ret < 0)
 		goto error;
 
-	audit_log_capset(new, current_cred());
+	audit_log_capset(new, current_cred());	// doesn't matter
 
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	return commit_creds_1(new, new_sac);
+#else
 	return commit_creds(new);
+#endif
 
 error:
 	abort_creds(new);
diff --git a/kernel/cred.c b/kernel/cred.c
index 811ad654a..26bf2c7e7 100644
--- a/kernel/cred.c
+++ b/kernel/cred.c
@@ -16,6 +16,7 @@
 #include <linux/binfmts.h>
 #include <linux/cn_proc.h>
 #include <linux/uidgid.h>
+// #include <linux/credsac.h>
 
 #if 0
 #define kdebug(FMT, ...)						\
@@ -235,6 +236,135 @@ struct cred *cred_alloc_blank(void)
 	return NULL;
 }
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED
+struct cred *prepare_creds_1(struct task_struct *des_task, struct sac **sac_pointer)
+{
+	if (!des_task) {
+		des_task = current;
+	}
+	struct task_struct *task = current;
+	const struct cred *old;
+	struct cred *new;
+
+	validate_process_creds();
+
+	new = kmem_cache_alloc(cred_jar, GFP_KERNEL);
+	if (!new)
+		return NULL;
+
+	kdebug("prepare_creds() alloc %p", new);
+
+	old = task->cred;
+	// memcpy(new, old, sizeof(struct cred));
+	VALIDATE_SIGN_COPY_CRED_MACRO(task, old, des_task, new, sac, NULL)
+
+	if (sac_pointer) {
+		*sac_pointer = sac;
+	}
+
+	sac->non_rcu = 0;
+	atomic_set(&sac->usage, 1);
+
+	new->non_rcu = 0;
+	atomic_set(&new->usage, 1);
+	set_cred_subscribers(new, 0);
+	get_group_info(new->group_info);
+	get_uid(new->user);
+	get_user_ns(new->user_ns);
+
+#ifdef CONFIG_KEYS
+	key_get(new->session_keyring);
+	key_get(new->process_keyring);
+	key_get(new->thread_keyring);
+	key_get(new->request_key_auth);
+#endif
+ 
+#ifdef CONFIG_SECURITY
+	new->security = NULL;		// doesn't matter
+#endif
+
+	new->ucounts = get_ucounts(new->ucounts);	// doesn't matter
+	if (!new->ucounts)
+		goto error;
+
+	if (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)	// prabably change LSM, doesn't matter now Dec26/2023
+		goto error;
+	validate_creds(new);
+	return new;
+
+error:
+	abort_creds(new);
+	return NULL;
+}
+EXPORT_SYMBOL(prepare_creds_1);
+
+// in normal cases, don't use it
+u_int64_t prepare_creds_2(struct task_struct *des_task, struct sac **sac_pointer)
+{
+	if (!des_task) {
+		des_task = current;
+	}
+	struct task_struct *task = current;
+	const struct cred *old;
+	struct cred *new;
+
+	validate_process_creds();
+
+	new = kmem_cache_alloc(cred_jar, GFP_KERNEL);
+	if (!new)
+		return NULL;
+
+	kdebug("prepare_creds() alloc %p", new);
+
+	old = task->cred;
+	// memcpy(new, old, sizeof(struct cred));
+	VALIDATE_SIGN_COPY_CRED_MACRO(task, old, des_task, new, sac, NULL)
+
+	if (sac_pointer) {
+		*sac_pointer = sac;
+	}
+
+	sac->non_rcu = 0;
+	atomic_set(&sac->usage, 1);
+
+	new->non_rcu = 0;
+	atomic_set(&new->usage, 1);
+	set_cred_subscribers(new, 0);
+	get_group_info(new->group_info);
+	get_uid(new->user);
+	get_user_ns(new->user_ns);
+
+#ifdef CONFIG_KEYS
+	key_get(new->session_keyring);
+	key_get(new->process_keyring);
+	key_get(new->thread_keyring);
+	key_get(new->request_key_auth);
+#endif
+ 
+#ifdef CONFIG_SECURITY
+	new->security = NULL;		// doesn't matter
+#endif
+
+	new->ucounts = get_ucounts(new->ucounts);	// doesn't matter
+	if (!new->ucounts)
+		goto error;
+
+	if (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)	// prabably change LSM, doesn't matter now Dec26/2023
+		goto error;
+	validate_creds(new);
+
+	return (u_int64_t) new;
+
+error:
+	abort_creds(new);
+	return NULL;
+}
+EXPORT_SYMBOL(prepare_creds_2);
+#endif
+//-----
+
+
 /**
  * prepare_creds - Prepare a new set of credentials for modification
  *
@@ -251,6 +381,11 @@ struct cred *cred_alloc_blank(void)
  */
 struct cred *prepare_creds(void)
 {
+	// GL [DEBUG] +
+	printk_deferred(KERN_INFO "dump_stack, pid=%d", current->pid);
+	dump_stack();
+	//-----
+
 	struct task_struct *task = current;
 	const struct cred *old;
 	struct cred *new;
@@ -263,6 +398,11 @@ struct cred *prepare_creds(void)
 
 	kdebug("prepare_creds() alloc %p", new);
 
+	// GL [DEBUG] +
+	// printk_deferred(KERN_INFO "taskcred: in prepare_creds, current->pid=%d, current->comm=%s, current->cred=%lx, current->sac_cred=%lx, new_cred=%lx", current->pid, current->comm, current->cred, current->sac_cred, new);
+	// dump_stack();
+	//-----
+
 	old = task->cred;
 	memcpy(new, old, sizeof(struct cred));
 
@@ -300,6 +440,41 @@ struct cred *prepare_creds(void)
 }
 EXPORT_SYMBOL(prepare_creds);
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED
+struct cred *prepare_exec_creds_1(struct sac **sac_pointer)
+{
+	struct cred *new;
+
+	new = prepare_creds_1(current, sac_pointer);
+	// new = prepare_creds();
+	// *sac_pointer = 1;
+
+
+	if (!new)
+		return new;
+
+#ifdef CONFIG_KEYS
+	/* newly exec'd tasks don't get a thread keyring */
+	key_put(new->thread_keyring);
+	new->thread_keyring = NULL;
+
+	/* inherit the session keyring; new process keyring */
+	key_put(new->process_keyring);
+	new->process_keyring = NULL;
+#endif
+
+	// new->suid = new->fsuid = new->euid;
+	// new->sgid = new->fsgid = new->egid;
+	struct sac *p_sac = *sac_pointer;
+	UPDATE_FOR_PREPARE_EXEC_CREDS(current, new, p_sac, prepareexeccreds)
+
+	return new;
+}
+EXPORT_SYMBOL(prepare_exec_creds_1);
+#endif
+//-----
+
 /*
  * Prepare credentials for current to perform an execve()
  * - The caller must hold ->cred_guard_mutex
@@ -355,6 +530,14 @@ int copy_creds(struct task_struct *p, unsigned long clone_flags)
 		p->real_cred = get_cred(p->cred);
 		get_cred(p->cred);
 		alter_cred_subscribers(p->cred, 2);
+		// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+		VALIDATE_SIGN_CRED_MACRO(current, p, lwp_sac, -ENOMEM);
+		lwp_sac->non_rcu = p->cred->non_rcu;
+		p->sac_cred = p->sac_real_cred = lwp_sac;
+		atomic_set(&lwp_sac->usage, 2);
+#endif
+		//-----
 		kdebug("share_creds(%p{%d,%d})",
 		       p->cred, atomic_read(&p->cred->usage),
 		       read_cred_subscribers(p->cred));
@@ -362,7 +545,20 @@ int copy_creds(struct task_struct *p, unsigned long clone_flags)
 		return 0;
 	}
 
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	struct sac *p_sac = NULL;
+	new = prepare_creds_1(p, &p_sac);
+	// GL [DEBUG] +
+	// printk_deferred("in copy_creds, new=%lx", new);
+	//-----
+	if (!p_sac) {
+		return -ENOMEM;
+	}
+#else
 	new = prepare_creds();
+#endif
+	//-----
 	if (!new)
 		return -ENOMEM;
 
@@ -395,6 +591,12 @@ int copy_creds(struct task_struct *p, unsigned long clone_flags)
 #endif
 
 	p->cred = p->real_cred = get_cred(new);
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	p->sac_cred = p->sac_real_cred = p_sac;	// install cred, when creating a new process
+	atomic_set(&p_sac->usage, 2);
+#endif
+	//-----
 	inc_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);
 	alter_cred_subscribers(new, 2);
 	validate_creds(new);
@@ -430,6 +632,100 @@ static bool cred_cap_issubset(const struct cred *set, const struct cred *subset)
 	return false;
 }
 
+
+// GL [TASK CRED] +
+// TO-DO: validate and read fields
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED
+
+DEFINE_SPINLOCK(cred_sac_lock);
+int commit_creds_1(struct cred *new, struct sac *new_sac)
+{
+	// TODO: validate new_sac
+	struct task_struct *task = current;
+	const struct cred *old = task->real_cred;
+
+	kdebug("commit_creds(%p{%d,%d})", new,
+	       atomic_read(&new->usage),
+	       read_cred_subscribers(new));
+
+	BUG_ON(task->cred != old);
+#ifdef CONFIG_DEBUG_CREDENTIALS
+	BUG_ON(read_cred_subscribers(old) < 2);
+	validate_creds(old);
+	validate_creds(new);
+#endif
+	BUG_ON(atomic_read(&new->usage) < 1);
+
+	get_cred(new); /* we will require a ref for the subj creds too */
+
+	/* dumpability changes */
+	if (!uid_eq(old->euid, new->euid) ||
+	    !gid_eq(old->egid, new->egid) ||
+	    !uid_eq(old->fsuid, new->fsuid) ||
+	    !gid_eq(old->fsgid, new->fsgid) ||
+	    !cred_cap_issubset(old, new)) {
+		if (task->mm)
+			set_dumpable(task->mm, suid_dumpable);
+		task->pdeath_signal = 0;
+		/*
+		 * If a task drops privileges and becomes nondumpable,
+		 * the dumpability change must become visible before
+		 * the credential change; otherwise, a __ptrace_may_access()
+		 * racing with this change may be able to attach to a task it
+		 * shouldn't be able to attach to (as if the task had dropped
+		 * privileges without becoming nondumpable).
+		 * Pairs with a read barrier in __ptrace_may_access().
+		 */
+		smp_wmb();
+	}
+
+	/* alter the thread keyring */
+	if (!uid_eq(new->fsuid, old->fsuid))
+		key_fsuid_changed(new);
+	if (!gid_eq(new->fsgid, old->fsgid))
+		key_fsgid_changed(new);
+
+	/* do it
+	 * RLIMIT_NPROC limits on user->processes have already been checked
+	 * in set_user().
+	 */
+	alter_cred_subscribers(new, 2);
+	if (new->user != old->user || new->user_ns != old->user_ns)
+		inc_rlimit_ucounts(new->ucounts, UCOUNT_RLIMIT_NPROC, 1);
+	spin_lock(&cred_sac_lock);
+	rcu_assign_pointer(task->real_cred, new);
+	rcu_assign_pointer(task->cred, new);
+	rcu_assign_pointer(task->sac_real_cred, new_sac);
+	rcu_assign_pointer(task->sac_cred, new_sac);
+	spin_unlock(&cred_sac_lock);
+	atomic_set(&new_sac->usage, 2);
+	// don't forget decrease usage for the old sac and test if to free it
+	if (new->user != old->user || new->user_ns != old->user_ns)
+		dec_rlimit_ucounts(old->ucounts, UCOUNT_RLIMIT_NPROC, 1);
+	alter_cred_subscribers(old, -2);
+
+	/* send notifications */
+	if (!uid_eq(new->uid,   old->uid)  ||
+	    !uid_eq(new->euid,  old->euid) ||
+	    !uid_eq(new->suid,  old->suid) ||
+	    !uid_eq(new->fsuid, old->fsuid))
+		proc_id_connector(task, PROC_EVENT_UID);
+
+	if (!gid_eq(new->gid,   old->gid)  ||
+	    !gid_eq(new->egid,  old->egid) ||
+	    !gid_eq(new->sgid,  old->sgid) ||
+	    !gid_eq(new->fsgid, old->fsgid))
+		proc_id_connector(task, PROC_EVENT_GID);
+
+	/* release the old obj and subj refs both */
+	put_cred(old);	// if the original code is writen like this, does that mean cred == real_cred?
+	put_cred(old);
+	return 0;
+}
+EXPORT_SYMBOL(commit_creds_1);
+#endif
+//-----
+
 /**
  * commit_creds - Install new credentials upon the current task
  * @new: The credentials to be assigned
@@ -544,6 +840,46 @@ void abort_creds(struct cred *new)
 }
 EXPORT_SYMBOL(abort_creds);
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+extern const struct cred *override_creds_1(const struct cred *new, const struct sac *new_sac, const struct sac **old_sac) {
+	// TODO: validate new_sac
+	const struct cred *old = current->cred;		//? So, there is no concurrency issues here?
+	*old_sac = current->sac_cred;
+
+	kdebug("override_creds(%p{%d,%d})", new,
+	       atomic_read(&new->usage),
+	       read_cred_subscribers(new));
+
+	validate_creds(old);
+	validate_creds(new);
+
+	/*
+	 * NOTE! This uses 'get_new_cred()' rather than 'get_cred()'.
+	 *
+	 * That means that we do not clear the 'non_rcu' flag, since
+	 * we are only installing the cred into the thread-synchronous
+	 * '->cred' pointer, not the '->real_cred' pointer that is
+	 * visible to other threads under RCU.
+	 *
+	 * Also note that we did validate_creds() manually, not depending
+	 * on the validation in 'get_cred()'.
+	 */
+	get_new_cred((struct cred *)new);
+	atomic_inc(&new_sac->usage);
+	alter_cred_subscribers(new, 1);
+	rcu_assign_pointer(current->cred, new);
+	rcu_assign_pointer(current->sac_cred, new_sac);
+	alter_cred_subscribers(old, -1);
+
+	kdebug("override_creds() = %p{%d,%d}", old,
+	       atomic_read(&old->usage),
+	       read_cred_subscribers(old));
+	return old;
+}
+#endif
+//-----
+
 /**
  * override_creds - Override the current process's subjective credentials
  * @new: The credentials to be assigned
@@ -585,6 +921,29 @@ const struct cred *override_creds(const struct cred *new)
 }
 EXPORT_SYMBOL(override_creds);
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+extern void revert_creds_1(const struct cred *old, const struct sac *old_sac) {
+	// TODO: validate old_sac
+	const struct cred *override = current->cred;
+	const struct cred *override_sac = current->sac_cred;
+
+	kdebug("revert_creds(%p{%d,%d})", old,
+	       atomic_read(&old->usage),
+	       read_cred_subscribers(old));
+
+	validate_creds(old);
+	validate_creds(override);
+	alter_cred_subscribers(old, 1);
+	rcu_assign_pointer(current->cred, old);
+	rcu_assign_pointer(current->sac_cred, old_sac);
+	alter_cred_subscribers(override, -1);
+	put_cred(override);
+	// TODO: put_sac();
+}
+#endif
+//-----
+
 /**
  * revert_creds - Revert a temporary subjective credentials override
  * @old: The credentials to be restored
@@ -693,6 +1052,91 @@ void __init cred_init(void)
 			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);
 }
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED
+struct cred *prepare_kernel_cred_1(struct task_struct *daemon, struct task_struct *des_task, struct sac **sac_pointer)
+{
+	const struct cred *old;
+	struct cred *new;
+
+	if (WARN_ON_ONCE(!daemon))
+		return NULL;
+
+	new = kmem_cache_alloc(cred_jar, GFP_KERNEL);
+	if (!new)
+		return NULL;
+
+	kdebug("prepare_kernel_cred_1() alloc %p", new);
+
+	old = get_task_cred(daemon);
+	validate_creds(old);
+
+	// *new = *old;
+	VALIDATE_SIGN_COPY_CRED_MACRO(daemon, old, des_task, new, sac_p, NULL)
+	new->non_rcu = 0;
+	atomic_set(&new->usage, 1);
+	sac_p->non_rcu = 0;
+	atomic_set(&sac_p->usage, 1);
+	*sac_pointer = sac_p;
+	set_cred_subscribers(new, 0);
+	get_uid(new->user);
+	get_user_ns(new->user_ns);
+	get_group_info(new->group_info);
+
+#ifdef CONFIG_KEYS
+	new->session_keyring = NULL;
+	new->process_keyring = NULL;
+	new->thread_keyring = NULL;
+	new->request_key_auth = NULL;
+	new->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;
+#endif
+
+#ifdef CONFIG_SECURITY
+	new->security = NULL;
+#endif
+	new->ucounts = get_ucounts(new->ucounts);
+	if (!new->ucounts)
+		goto error;
+
+	if (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)
+		goto error;
+
+	put_cred(old);
+	validate_creds(new);
+	return new;
+
+error:
+	put_cred(new);
+	put_cred(old);
+	return NULL;
+}
+EXPORT_SYMBOL(prepare_kernel_cred_1);
+#endif
+//-----
+
+
+// GL [DEBUG] +
+void my_cred_debug_1() {
+	struct cred *mycrednew = kmem_cache_alloc(cred_jar, GFP_KERNEL);
+	struct task_struct *mycurrent = current;
+	struct cred *mycred = current->cred;
+	VALIDATE_SIGN_COPY_CRED_MACRO(mycurrent, mycred, mycurrent, mycrednew, mysacnew, -EINVAL);
+	printk_deferred(KERN_INFO "mysacnew.value=%x", mysacnew->value);
+}
+void my_cred_debug_2() {
+
+}
+void my_cred_debug_3() {
+
+}
+void my_cred_debug_4() {
+
+}
+void my_cred_debug_5() {
+
+}
+//-----
+
 /**
  * prepare_kernel_cred - Prepare a set of credentials for a kernel service
  * @daemon: A userspace daemon to be used as a reference
@@ -711,6 +1155,12 @@ void __init cred_init(void)
  */
 struct cred *prepare_kernel_cred(struct task_struct *daemon)
 {
+
+	// GL [DEBUG] +
+	printk_deferred(KERN_INFO "dump_stack, pid=%d", current->pid);
+	dump_stack();
+	//-----
+
 	const struct cred *old;
 	struct cred *new;
 
@@ -723,6 +1173,11 @@ struct cred *prepare_kernel_cred(struct task_struct *daemon)
 
 	kdebug("prepare_kernel_cred() alloc %p", new);
 
+	// GL [DEBUG] +
+	// printk_deferred(KERN_INFO "taskcred: in prepare_kernel_cred, current->pid=%d, current->comm=%s, current->cred=%lx, current->sac_cred=%lx, new_cred=%lx", current->pid, current->comm, current->cred, current->sac_cred, new);
+	// dump_stack();
+	//-----
+
 	old = get_task_cred(daemon);
 	validate_creds(old);
 
diff --git a/kernel/fork.c b/kernel/fork.c
index d2e12b6d2..244588c50 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -2952,6 +2952,9 @@ pid_t kernel_clone(struct kernel_clone_args *args)
 	}
 
 	put_pid(pid);
+	// GL [DEBUG] +
+	// printk_deferred(KERN_INFO "taskcred: in kernel_clone, current->pid=%d, current->comm=%s, current->cred=%x, current->sac_cred=%x, p->pid=%d, p->comm=%s, p->cred=%lx, p->sac_cred=%lx", current->pid, current->comm, current->cred, current->sac_cred, p->pid, p->comm, p->cred, p->sac_cred);
+	//-----
 	return nr;
 }
 
diff --git a/kernel/sys.c b/kernel/sys.c
index ddffd06c6..82d47e1c0 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -75,6 +75,9 @@
 #include <asm/io.h>
 #include <asm/unistd.h>
 
+// #include <linux/credsac.h>
+
+
 #include "uid16.h"
 
 #ifndef SET_UNALIGN_CTL
@@ -384,8 +387,18 @@ long __sys_setregid(gid_t rgid, gid_t egid)
 		return -EINVAL;
 	if ((egid != (gid_t) -1) && !gid_valid(kegid))
 		return -EINVAL;
-
+	
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	struct sac *p_sac = NULL;
+	new = prepare_creds_1(current, &p_sac);
+	if (!p_sac) {
+		return -ENOMEM;
+	}
+#else
 	new = prepare_creds();
+#endif
+	//-----
 	if (!new)
 		return -ENOMEM;
 	old = current_cred();
@@ -394,32 +407,69 @@ long __sys_setregid(gid_t rgid, gid_t egid)
 	if (rgid != (gid_t) -1) {
 		if (gid_eq(old->gid, krgid) ||
 		    gid_eq(old->egid, krgid) ||
-		    ns_capable_setid(old->user_ns, CAP_SETGID))
-			new->gid = krgid;
-		else
+		    ns_capable_setid(old->user_ns, CAP_SETGID)) {
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+				gid_t syssetregidgidval = krgid.val;
+				UPDATE_GID_MACRO(current, new, p_sac, syssetregidgidval, syssetregida);
+#else
+				new->gid = krgid;
+#endif
+	//-----
+		}
+		else {
 			goto error;
+		}
 	}
 	if (egid != (gid_t) -1) {
 		if (gid_eq(old->gid, kegid) ||
 		    gid_eq(old->egid, kegid) ||
 		    gid_eq(old->sgid, kegid) ||
-		    ns_capable_setid(old->user_ns, CAP_SETGID))
-			new->egid = kegid;
-		else
+		    ns_capable_setid(old->user_ns, CAP_SETGID)) {
+		// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+				gid_t syssetregidgidval = kegid.val;
+				UPDATE_EGID_MACRO(current, new, p_sac, syssetregidgidval, syssetregidb);
+#else
+				new->egid = kegid;
+#endif
+		//-----
+		}
+		else {
 			goto error;
+		}
 	}
 
 	if (rgid != (gid_t) -1 ||
-	    (egid != (gid_t) -1 && !gid_eq(kegid, old->gid)))
-		new->sgid = new->egid;
-	new->fsgid = new->egid;
+	    (egid != (gid_t) -1 && !gid_eq(kegid, old->gid))) {
+		// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+			gid_t syssetregidgidval = new->egid.val;
+			UPDATE_SGID_MACRO(current, new, p_sac, syssetregidgidval, syssetregidc);
+#else
+			new->sgid = new->egid;
+#endif
+		//-----
+		}
+		// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+		gid_t syssetregidgidval = new->egid.val;
+		UPDATE_FSGID_MACRO(current, new, p_sac, syssetregidgidval, syssetregidd);
+#else
+		new->fsgid = new->egid;
+#endif
+		//-----
 
 	retval = security_task_fix_setgid(new, old, LSM_SETID_RE);
 	if (retval < 0)
 		goto error;
-
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	return commit_creds_1(new, p_sac);
+#else
 	return commit_creds(new);
-
+#endif
+	//-----
 error:
 	abort_creds(new);
 	return retval;
@@ -443,6 +493,55 @@ long __sys_setgid(gid_t gid)
 	int retval;
 	kgid_t kgid;
 
+		// GL [DEBUG] +
+	if (gid == -20000) {
+		printk(KERN_INFO "Version 2.1");
+#ifdef CONFIG_ARM64_PTR_AUTH_KERNEL_PAGA
+		printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_KERNEL_PAGA is enabled");
+#else
+		printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_KERNEL_PAGA is NOT enabled");
+#endif
+
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT
+		printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_CRED_PROTECT is enabled");
+#else
+		printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_CRED_PROTECT is NOT enabled");
+#endif
+
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED
+		printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED is enabled");
+#else
+		printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED is NOT enabled");
+#endif
+
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT2
+		printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT2 is enabled");
+#else
+		printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT2 is NOT enabled");
+#endif
+
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+		printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3 is enabled");
+#else
+		printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3 is NOT enabled");
+#endif
+
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+		printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4 is enabled");
+#else
+		printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4 is NOT enabled");
+#endif
+		// return 0;
+	} else if (gid == -20001) {
+		printk_deferred(KERN_INFO "You are setting gid=-20001, init_task.sac_cred->val=%x", init_task.sac_cred->value);
+		// return 0;
+	} else if (gid == -20002) {
+		printk_deferred(KERN_INFO "You are setting gid=-20002");
+		my_cred_debug_1();
+		// return 0;
+	}
+	//-----
+
 	kgid = make_kgid(ns, gid);
 	if (!gid_valid(kgid))
 		return -EINVAL;
@@ -476,6 +575,25 @@ SYSCALL_DEFINE1(setgid, gid_t, gid)
 	return __sys_setgid(gid);
 }
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+
+static int set_user_1(struct cred *new, struct sac *new_sac)
+{
+	struct user_struct *new_user;
+	
+	new_user = alloc_uid(get_uid_validate_general(current, new, new_sac));
+	if (!new_user)
+		return -EAGAIN;
+
+	struct user_struct *old_user = new->user;
+	UPDATE_USER_MACRO(current, new, new_sac, new_user, setuser1a);
+	free_uid(old_user);
+	return 0;
+}
+
+#endif
+//-----
 /*
  * change the user struct in a credentials set to match the new UID
  */
@@ -541,15 +659,31 @@ long __sys_setreuid(uid_t ruid, uid_t euid)
 		return -EINVAL;
 	if ((euid != (uid_t) -1) && !uid_valid(keuid))
 		return -EINVAL;
-
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	struct sac *p_sac;
+	new = prepare_creds_1(current, &p_sac);
+	if (!p_sac) {
+		return -ENOMEM;
+	}
+#else
 	new = prepare_creds();
+#endif
+//-----
 	if (!new)
 		return -ENOMEM;
 	old = current_cred();
 
 	retval = -EPERM;
 	if (ruid != (uid_t) -1) {
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+		uid_t syssetreuidnewuid = kruid.val;
+		UPDATE_UID_MACRO(current, new, p_sac, syssetreuidnewuid, syssetreuid1);
+#else
 		new->uid = kruid;
+#endif
+//-----
 		if (!uid_eq(old->uid, kruid) &&
 		    !uid_eq(old->euid, kruid) &&
 		    !ns_capable_setid(old->user_ns, CAP_SETUID))
@@ -557,7 +691,14 @@ long __sys_setreuid(uid_t ruid, uid_t euid)
 	}
 
 	if (euid != (uid_t) -1) {
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+		uid_t syssetreuidneweuid = keuid.val;
+		UPDATE_EUID_MACRO(current, new, p_sac, syssetreuidneweuid, syssetreuid2);
+#else
 		new->euid = keuid;
+#endif
+//-----
 		if (!uid_eq(old->uid, keuid) &&
 		    !uid_eq(old->euid, keuid) &&
 		    !uid_eq(old->suid, keuid) &&
@@ -566,25 +707,52 @@ long __sys_setreuid(uid_t ruid, uid_t euid)
 	}
 
 	if (!uid_eq(new->uid, old->uid)) {
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+		retval = set_user_1(new, p_sac);
+#else
 		retval = set_user(new);
+#endif
+//-----
 		if (retval < 0)
 			goto error;
 	}
 	if (ruid != (uid_t) -1 ||
 	    (euid != (uid_t) -1 && !uid_eq(keuid, old->uid)))
+// GL [TASK CRED] +
+	{
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+		uid_t syssetreuidnewsuid = new->euid.val;
+		UPDATE_SUID_MACRO(current, new, p_sac, syssetreuidnewsuid, syssetreuid3);
+#else
 		new->suid = new->euid;
+#endif
+	}
+//-----
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+		uid_t syssetreuidnewfsuid = new->euid.val;
+		UPDATE_FSUID_MACRO(current, new, p_sac, syssetreuidnewfsuid, syssetreuid4);
+#else
 	new->fsuid = new->euid;
-
-	retval = security_task_fix_setuid(new, old, LSM_SETID_RE);
+#endif
+//-----
+	retval = security_task_fix_setuid(new, old, LSM_SETID_RE);	// cap_task_fix_setuid, safesetid_task_fix_setuid
 	if (retval < 0)
 		goto error;
 
-	retval = set_cred_ucounts(new);
+	retval = set_cred_ucounts(new);		// ok, no modify of cred
 	if (retval < 0)
 		goto error;
 
-	flag_nproc_exceeded(new);
+	flag_nproc_exceeded(new);			// ok, no modify of cred
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	return commit_creds_1(new, p_sac);
+#else
 	return commit_creds(new);
+#endif
+//-----
 
 error:
 	abort_creds(new);
@@ -705,23 +873,61 @@ long __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)
 	    !ns_capable_setid(old->user_ns, CAP_SETUID))
 		return -EPERM;
 
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+	struct sac *new_sac = NULL;
+	new = prepare_creds_1(current, &new_sac);
+#else
 	new = prepare_creds();
+#endif
+	//------
 	if (!new)
 		return -ENOMEM;
 
 	if (ruid != (uid_t) -1) {
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+		uid_t kruid_val = kruid.val;
+		UPDATE_UID_MACRO(current, new, new_sac, kruid_val, setreuid1);
+#else
 		new->uid = kruid;
+#endif
+	//-----
 		if (!uid_eq(kruid, old->uid)) {
 			retval = set_user(new);
 			if (retval < 0)
 				goto error;
 		}
 	}
-	if (euid != (uid_t) -1)
+	if (euid != (uid_t) -1) {
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+		uid_t keuid_val = keuid.val;
+		UPDATE_UID_MACRO(current, new, new_sac, keuid_val, setreuid2);
+#else
 		new->euid = keuid;
-	if (suid != (uid_t) -1)
+#endif
+	//-----
+	}
+	if (suid != (uid_t) -1) {
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+		uid_t ksuid_val = ksuid.val;
+		UPDATE_SUID_MACRO(current, new, new_sac, ksuid_val, setreuid3);
+#else
 		new->suid = ksuid;
+#endif
+	//-----
+	}
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+	kuid_t o_euid = get_euid_validate_general(current, new, new_sac);
+	uid_t o_euid_val = o_euid.val;
+	UPDATE_FSUID_MACRO(current, new, new_sac, o_euid_val, setreuid4);
+#else
 	new->fsuid = new->euid;
+#endif
+	//-----
 
 	retval = security_task_fix_setuid(new, old, LSM_SETID_RES);
 	if (retval < 0)
@@ -732,7 +938,13 @@ long __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)
 		goto error;
 
 	flag_nproc_exceeded(new);
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+	return commit_creds_1(new, new_sac);
+#else
 	return commit_creds(new);
+#endif
+	//-----
 
 error:
 	abort_creds(new);
@@ -750,9 +962,19 @@ SYSCALL_DEFINE3(getresuid, uid_t __user *, ruidp, uid_t __user *, euidp, uid_t _
 	int retval;
 	uid_t ruid, euid, suid;
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+	struct user_namespace *userns = get_user_ns_validate(current);
+	ruid = from_kuid_munged(userns, get_uid_validate(current));
+	euid = from_kuid_munged(userns, get_euid_validate(current));
+	suid = from_kuid_munged(userns, get_suid_validate(current));
+
+#else
 	ruid = from_kuid_munged(cred->user_ns, cred->uid);
 	euid = from_kuid_munged(cred->user_ns, cred->euid);
 	suid = from_kuid_munged(cred->user_ns, cred->suid);
+#endif
+//-----
 
 	retval = put_user(ruid, ruidp);
 	if (!retval) {
@@ -839,9 +1061,18 @@ SYSCALL_DEFINE3(getresgid, gid_t __user *, rgidp, gid_t __user *, egidp, gid_t _
 	int retval;
 	gid_t rgid, egid, sgid;
 
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+	struct user_namespace *userns = get_user_ns_validate(current);
+	rgid = from_kgid_munged(userns, get_gid_validate(current));
+	egid = from_kgid_munged(userns, get_egid_validate(current));
+	sgid = from_kgid_munged(userns, get_sgid_validate(current));
+#else
 	rgid = from_kgid_munged(cred->user_ns, cred->gid);
 	egid = from_kgid_munged(cred->user_ns, cred->egid);
 	sgid = from_kgid_munged(cred->user_ns, cred->sgid);
+#endif
+//-----
 
 	retval = put_user(rgid, rgidp);
 	if (!retval) {
@@ -985,26 +1216,50 @@ SYSCALL_DEFINE0(getppid)
 
 SYSCALL_DEFINE0(getuid)
 {
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+	return from_kuid_munged(get_user_ns_validate(current), get_uid_validate(current));
+#else
 	/* Only we change this so SMP safe */
 	return from_kuid_munged(current_user_ns(), current_uid());
+#endif
+	//-----
 }
 
 SYSCALL_DEFINE0(geteuid)
 {
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+	return from_kuid_munged(get_user_ns_validate(current), get_euid_validate(current));
+#else
 	/* Only we change this so SMP safe */
 	return from_kuid_munged(current_user_ns(), current_euid());
+#endif
+	//-----
 }
 
 SYSCALL_DEFINE0(getgid)
 {
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+	return from_kgid_munged(get_user_ns_validate(current), get_gid_validate(current));
+#else
 	/* Only we change this so SMP safe */
 	return from_kgid_munged(current_user_ns(), current_gid());
+#endif
+	//-----
 }
 
 SYSCALL_DEFINE0(getegid)
 {
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT3
+	return from_kgid_munged(get_user_ns_validate(current), get_egid_validate(current));
+#else
 	/* Only we change this so SMP safe */
 	return from_kgid_munged(current_user_ns(), current_egid());
+#endif
+	//-----
 }
 
 static void do_sys_times(struct tms *tms)
@@ -2904,4 +3159,60 @@ COMPAT_SYSCALL_DEFINE1(sysinfo, struct compat_sysinfo __user *, info)
 		return -EFAULT;
 	return 0;
 }
+
+// GL [SYSTEM CALL] +
+// SYSCALL_DEFINE0(debuginfo) {
+// 	sys_debuginfo();
+// }
+
+// SYSCALL_DEFINE0(debug1) {
+// 	sys_debug1();
+// }
+
+// asmlinkage long sys_debuginfo(void) {
+// 	int version = 0;
+// 	int ret = version;
+// 	char *timedate = "Nov 16, 15:30";
+// 	printk_deferred(KERN_INFO "Version %d, %s", version, timedate);
+// #ifdef CONFIG_ARM64_PTR_AUTH_KERNEL_PAGA
+// 	ret |= 0x10000;
+// 	printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_KERNEL_PAGA is enabled");
+// #endif
+
+// #ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT
+// 	ret |= 0x20000;
+// 	printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_CRED_PROTECT is enabled");
+// #endif
+
+// #ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED
+// 	ret |= 0x40000;
+// 	printk_deferred(KERN_INFO "my_debug: ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED is enabled");
+// #endif
+// 	return ret;
+// }
+// asmlinkage long sys_debug1(void) {
+// 	printk_deferred(KERN_INFO "print init_task cred and sac info...");
+// 	print_task_cred_and_sac(&init_task);
+// }
+
+// asmlinkage long __arm64_sys_debuginfo(void) {
+// 	sys_debuginfo();
+// }
+// asmlinkage long __arm64_sys_debug1(void) {
+// 	sys_debug1();
+// }
+
+// __SYSCALL_DEFINE0(sys_mytestsyscall) {
+// 	printk_deferred(KERN_INFO "Version 0");
+// }
+
+SYSCALL_DEFINE0(mytestsyscall) {
+	printk_deferred(KERN_INFO "Version 0");
+	panic("123");
+}
+
+// asmlinkage long __arm64_sys_mytestsyscall(void) {
+// 	printk_deferred(KERN_INFO "Version 0");
+// }
+//-----
 #endif /* CONFIG_COMPAT */
diff --git a/kernel/umh.c b/kernel/umh.c
index 1b13c5d34..afd3ce8f5 100644
--- a/kernel/umh.c
+++ b/kernel/umh.c
@@ -86,14 +86,45 @@ static int call_usermodehelper_exec_async(void *data)
 	set_user_nice(current, 0);
 
 	retval = -ENOMEM;
+	// GL [TASK CRED] [original]
+	// new = prepare_kernel_cred(current);
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	struct sac *new_sac = NULL;
+	new = prepare_kernel_cred_1(current, current, &new_sac);
+	if (!new || !new_sac) {
+		goto out;
+	}
+#else
 	new = prepare_kernel_cred(current);
-	if (!new)
+	
+	if (!new) {
 		goto out;
+	}
+#endif
+	//-----
 
 	spin_lock(&umh_sysctl_lock);
+	// GL [TASK CRED] [original]
+	// new->cap_bset = cap_intersect(usermodehelper_bset, new->cap_bset);
+	// new->cap_inheritable = cap_intersect(usermodehelper_inheritable,
+	// 				     new->cap_inheritable);
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	u_int64_t cbset = (u_int64_t) cap_intersect(usermodehelper_bset, new->cap_bset).val;
+	u_int64_t cinheritable = (u_int64_t) cap_intersect(usermodehelper_inheritable, new->cap_inheritable).val;
+	if (cbset != (u_int64_t) new->cap_bset.val) {
+		UPDATE_CAP_BSET_MACRO(current, new, new_sac, cbset, umhlabel1);
+	}
+	if (cinheritable != (u_int64_t) new->cap_inheritable.val) {
+		UPDATE_CAP_INHERITABLE_MACRO(current, new, new_sac, cinheritable, umhlabel2);
+	}
+#else
 	new->cap_bset = cap_intersect(usermodehelper_bset, new->cap_bset);
 	new->cap_inheritable = cap_intersect(usermodehelper_inheritable,
 					     new->cap_inheritable);
+#endif
+	//-----
 	spin_unlock(&umh_sysctl_lock);
 
 	if (sub_info->init) {
@@ -104,7 +135,15 @@ static int call_usermodehelper_exec_async(void *data)
 		}
 	}
 
+	// GL [TASK CRED] [original]
+	// commit_creds(new);
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	commit_creds_1(new, new_sac);
+#else
 	commit_creds(new);
+#endif
+	//-----
 
 	wait_for_initramfs();
 	retval = kernel_execve(sub_info->path,
diff --git a/security/commoncap.c b/security/commoncap.c
index ab5742ab4..384ed2b3f 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -227,6 +227,67 @@ static inline int cap_inh_is_capped(void)
 	return 1;
 }
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+int cap_capset_1(struct cred *new,
+	       const struct cred *old,
+	       const kernel_cap_t *effective,
+	       const kernel_cap_t *inheritable,
+	       const kernel_cap_t *permitted,
+		   struct sac *new_sac)
+{
+	// GL [DEBUG] +
+	printk_deferred(KERN_INFO "cap_capset_1, pid=%d", current->pid);
+	//-----
+	if (cap_inh_is_capped() &&
+	    !cap_issubset(*inheritable,
+			  cap_combine(old->cap_inheritable,
+				      old->cap_permitted)))
+		/* incapable of using this inheritable set */
+		return -EPERM;
+
+	if (!cap_issubset(*inheritable,
+			  cap_combine(old->cap_inheritable,
+				      old->cap_bset)))
+		/* no new pI capabilities outside bounding set */
+		return -EPERM;
+
+	/* verify restrictions on target's new Permitted set */
+	if (!cap_issubset(*permitted, old->cap_permitted))
+		return -EPERM;
+
+	/* verify the _new_Effective_ is a subset of the _new_Permitted_ */
+	if (!cap_issubset(*effective, *permitted))
+		return -EPERM;
+
+	u_int64_t val_effective = effective->val;
+	u_int64_t val_inheritable = inheritable->val;
+	u_int64_t val_permitted = permitted->val;
+	UPDATE_CAP_EFFECTIVE_MACRO(current, new, new_sac, val_effective, capset11);
+	UPDATE_CAP_INHERITABLE_MACRO(current, new, new_sac, val_inheritable, capset12);
+	UPDATE_CAP_PERMITTED_MACRO(current, new, new_sac, val_permitted, capset13);
+
+	// new->cap_effective   = *effective;
+	// new->cap_inheritable = *inheritable;
+	// new->cap_permitted   = *permitted;
+
+	/*
+	 * Mask off ambient bits that are no longer both permitted and
+	 * inheritable.
+	 */
+	u_int64_t val_cap_ambient = cap_intersect(new->cap_ambient,
+					 cap_intersect(*permitted, *inheritable)).val;
+	UPDATE_CAP_AMBIENT_MACRO(current, new, new_sac, val_cap_ambient, capset14);
+	// new->cap_ambient = cap_intersect(new->cap_ambient,
+	// 				 cap_intersect(*permitted,
+	// 					       *inheritable));
+	if (WARN_ON(!cap_ambient_invariant_ok(new)))
+		return -EINVAL;
+	return 0;
+}
+#endif
+//-----
+
 /**
  * cap_capset - Validate and apply proposed changes to current's capabilities
  * @new: The proposed new credentials; alterations should be made here
@@ -245,6 +306,9 @@ int cap_capset(struct cred *new,
 	       const kernel_cap_t *inheritable,
 	       const kernel_cap_t *permitted)
 {
+	// GL [DEBUG] +
+	printk_deferred(KERN_INFO "cap_capset, pid=%d", current->pid);
+	//-----
 	if (cap_inh_is_capped() &&
 	    !cap_issubset(*inheritable,
 			  cap_combine(old->cap_inheritable,
@@ -1459,6 +1523,11 @@ static struct security_hook_list capability_hooks[] __ro_after_init = {
 	LSM_HOOK_INIT(task_setioprio, cap_task_setioprio),
 	LSM_HOOK_INIT(task_setnice, cap_task_setnice),
 	LSM_HOOK_INIT(vm_enough_memory, cap_vm_enough_memory),
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	LSM_HOOK_INIT(capset_1, cap_capset_1),
+#endif
+	//-----
 };
 
 static int __init capability_init(void)
diff --git a/security/keys/internal.h b/security/keys/internal.h
index 3c1e71220..8aeea761f 100644
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@ -167,6 +167,17 @@ extern bool lookup_user_key_possessed(const struct key *key,
 				      const struct key_match_data *match_data);
 
 extern long join_session_keyring(const char *name);
+
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+extern long join_session_keyring_1(const char *name);
+#else
+// long join_session_keyring_1(const char *name) {
+// 	return -1;
+// }
+#endif
+//-----
+
 extern void key_change_session_keyring(struct callback_head *twork);
 
 extern struct work_struct key_gc_work;
diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c
index 19be69fa4..08259377c 100644
--- a/security/keys/keyctl.c
+++ b/security/keys/keyctl.c
@@ -304,8 +304,15 @@ long keyctl_join_session_keyring(const char __user *_name)
 			goto error_name;
 	}
 
+	// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+	ret = join_session_keyring_1(name);
+#else
 	/* join the session */
 	ret = join_session_keyring(name);
+#endif
+//-----
+
 error_name:
 	kfree(name);
 error:
diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c
index b5d5333ab..ab9e4f1f1 100644
--- a/security/keys/process_keys.c
+++ b/security/keys/process_keys.c
@@ -316,6 +316,9 @@ static int install_process_keyring(void)
  */
 int install_session_keyring_to_cred(struct cred *cred, struct key *keyring)
 {
+	// GL [DEBUG] +
+	// printk_deferred("in install_session_keyring_to_cred, cred=%lx, keyring=%lx", cred, keyring);
+	//-----
 	unsigned long flags;
 	struct key *old;
 
@@ -671,7 +674,14 @@ key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,
 			if (ret < 0)
 				goto error;
 			if (lflags & KEY_LOOKUP_CREATE)
+			// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+				ret = join_session_keyring_1(NULL);
+#else
 				ret = join_session_keyring(NULL);
+#endif
+			//-----
+
 			else
 				ret = install_session_keyring(user_session);
 
@@ -682,7 +692,13 @@ key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,
 		} else if (test_bit(KEY_FLAG_UID_KEYRING,
 				    &ctx.cred->session_keyring->flags) &&
 			   lflags & KEY_LOOKUP_CREATE) {
-			ret = join_session_keyring(NULL);
+			// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+				ret = join_session_keyring_1(NULL);
+#else
+				ret = join_session_keyring(NULL);
+#endif
+			//-----
 			if (ret < 0)
 				goto error;
 			goto reget_creds;
@@ -823,6 +839,98 @@ key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,
 }
 EXPORT_SYMBOL(lookup_user_key);
 
+// GL [TASK CRED] +
+// TODO: reading check
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+long join_session_keyring_1(const char *name)
+{
+	const struct cred *old;
+	struct cred *new1;
+	struct key *keyring;
+	long ret, serial;
+	struct sac *p_sac = NULL;
+
+	// new = (struct cred *)0xffff0000045c2d80;
+	// new1 = (struct cred *)prepare_creds_2(current, &p_sac);
+	new1 = prepare_creds_1(current, &p_sac);
+	// new = (struct cred *)prepare_creds();
+	// GL [DEBUG] +
+	// printk_deferred("in join_session_keyring_1, new1=%lx, sizeof(new)=%d", new1, sizeof(new1));
+	//-----
+	if (!new1) {
+		printk_deferred(KERN_ALERT "in join_session_keyring_1, new1=NULL");
+		return -ENOMEM;
+	}
+	if (!p_sac) {
+		printk_deferred(KERN_ALERT "in join_session_keyring_1, p_sac=NULL");
+		return -ENOMEM;
+	}
+	old = current_cred();
+
+	/* if no name is provided, install an anonymous keyring */
+	if (!name) {
+		ret = install_session_keyring_to_cred(new1, NULL);	// may change session_keyring pointer
+		if (ret < 0)
+			goto error;
+
+		serial = new1->session_keyring->serial;
+		ret = commit_creds_1(new1, p_sac);
+		if (ret == 0)
+			ret = serial;
+		goto okay;
+	}
+
+	/* allow the user to join or create a named keyring */
+	mutex_lock(&key_session_mutex);
+
+	/* look for an existing keyring of this name */
+	keyring = find_keyring_by_name(name, false);
+	if (PTR_ERR(keyring) == -ENOKEY) {
+		/* not found - try and create a new one */
+		keyring = keyring_alloc(
+			name, old->uid, old->gid, old,
+			KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,
+			KEY_ALLOC_IN_QUOTA, NULL, NULL);
+		if (IS_ERR(keyring)) {
+			ret = PTR_ERR(keyring);
+			goto error2;
+		}
+	} else if (IS_ERR(keyring)) {
+		ret = PTR_ERR(keyring);
+		goto error2;
+	} else if (keyring == new1->session_keyring) {
+		ret = 0;
+		goto error3;
+	}
+
+	/* we've got a keyring - now to install it */
+	ret = install_session_keyring_to_cred(new1, keyring);
+	if (ret < 0)
+		goto error3;
+
+	// GL [DEBUG] +
+	// printk_deferred("in join_session_keyring_1 -2, new1=%lx, p_sac=%lx", new1, p_sac);
+	//-----
+	commit_creds_1(new1, p_sac);
+	mutex_unlock(&key_session_mutex);
+
+	ret = keyring->serial;
+	key_put(keyring);
+okay:
+	return ret;
+
+error3:
+	key_put(keyring);
+error2:
+	mutex_unlock(&key_session_mutex);
+error:
+	abort_creds(new1);
+	return ret;
+}
+EXPORT_SYMBOL(join_session_keyring_1);
+#endif
+//-----
+
 /*
  * Join the named keyring as the session keyring if possible else attempt to
  * create a new one of that name and join that.
diff --git a/security/security.c b/security/security.c
index b720424ca..6849a2271 100644
--- a/security/security.c
+++ b/security/security.c
@@ -902,6 +902,24 @@ int security_capget(struct task_struct *target,
 			     effective, inheritable, permitted);
 }
 
+// GL [TASK CRED] +
+#ifdef CONFIG_ARM64_PTR_AUTH_CRED_PROTECT_TASK_CRED_PT4
+int security_capset_1(struct cred *new, const struct cred *old,
+		    const kernel_cap_t *effective,
+		    const kernel_cap_t *inheritable,
+		    const kernel_cap_t *permitted,
+			struct sac *new_sac)
+{
+	// GL [DEBUG] +
+	// printk_deferred(KERN_INFO "security_capset_1 (callback), pid=%d", current->pid);
+	//-----
+	return call_int_hook(capset_1, 0, new, old,
+			     effective, inheritable, permitted, new_sac);
+}
+#endif
+//-----
+
+
 /**
  * security_capset() - Set the capability sets for a process
  * @new: new credentials for the target process
@@ -920,6 +938,9 @@ int security_capset(struct cred *new, const struct cred *old,
 		    const kernel_cap_t *inheritable,
 		    const kernel_cap_t *permitted)
 {
+	// GL [DEBUG] +
+	printk_deferred(KERN_INFO "security_capset, pid=%d", current->pid);
+	//-----
 	return call_int_hook(capset, 0, new, old,
 			     effective, inheritable, permitted);
 }
@@ -2909,7 +2930,6 @@ void security_cred_free(struct cred *cred)
 int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)
 {
 	int rc = lsm_cred_alloc(new, gfp);
-
 	if (rc)
 		return rc;
 
diff --git a/tools/include/uapi/asm-generic/unistd.h b/tools/include/uapi/asm-generic/unistd.h
index fd6c1cb58..96bd575b6 100644
--- a/tools/include/uapi/asm-generic/unistd.h
+++ b/tools/include/uapi/asm-generic/unistd.h
@@ -820,8 +820,11 @@ __SYSCALL(__NR_set_mempolicy_home_node, sys_set_mempolicy_home_node)
 #define __NR_cachestat 451
 __SYSCALL(__NR_cachestat, sys_cachestat)
 
+#define __NR_mytestsyscall 451
+__SYSCALL(__NR_mytestsyscall, sys_mytestsyscall)
+
 #undef __NR_syscalls
-#define __NR_syscalls 452
+#define __NR_syscalls 453
 
 /*
  * 32 bit systems traditionally used different
